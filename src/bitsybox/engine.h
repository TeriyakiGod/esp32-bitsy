#ifndef ENGINE_H
#define ENGINE_H

char* bitsy_js =
	"var room = {};\n"
	"var tile = {};\n"
	"var sprite = {};\n"
	"var item = {};\n"
	"var dialog = {};\n"
	"var palette = { //start off with a default palette\n"
	"		\"default\" : {\n"
	"			name : \"default\",\n"
	"			colors : [[0,0,0],[255,255,255],[255,255,255]]\n"
	"		}\n"
	"	};\n"
	"var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)\n"
	"var playerId = \"A\";\n"
	"\n"
	"var titleDialogId = \"title\";\n"
	"function getTitle() {\n"
	"	return dialog[titleDialogId].src;\n"
	"}\n"
	"function setTitle(titleSrc) {\n"
	"	dialog[titleDialogId] = { src:titleSrc, name:null };\n"
	"}\n"
	"\n"
	"var defaultFontName = \"ascii_small\";\n"
	"var fontName = defaultFontName;\n"
	"var TextDirection = {\n"
	"	LeftToRight : \"LTR\",\n"
	"	RightToLeft : \"RTL\"\n"
	"};\n"
	"var textDirection = TextDirection.LeftToRight;\n"
	"\n"
	"/* NAME-TO-ID MAPS */\n"
	"var names = {\n"
	"	room : {},\n"
	"	tile : {},\n"
	"	sprite : {},\n"
	"	item : {},\n"
	"	dialog : {},\n"
	"};\n"
	"\n"
	"function updateNamesFromCurData() {\n"
	"\n"
	"	function createNameMap(objectStore) {\n"
	"		var map = {};\n"
	"\n"
	"		for (id in objectStore) {\n"
	"			if (objectStore[id].name != undefined && objectStore[id].name != null) {\n"
	"				map[objectStore[id].name] = id;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return map;\n"
	"	}\n"
	"\n"
	"	names.room = createNameMap(room);\n"
	"	names.tile = createNameMap(tile);\n"
	"	names.sprite = createNameMap(sprite);\n"
	"	names.item = createNameMap(item);\n"
	"	names.dialog = createNameMap(dialog);\n"
	"}\n"
	"\n"
	"var spriteStartLocations = {};\n"
	"\n"
	"/* VERSION */\n"
	"var version = {\n"
	"	major: 7, // major changes\n"
	"	minor: 8, // smaller changes\n"
	"	devBuildPhase: \"RELEASE\",\n"
	"};\n"
	"function getEngineVersion() {\n"
	"	return version.major + \".\" + version.minor;\n"
	"}\n"
	"\n"
	"/* FLAGS */\n"
	"var flags;\n"
	"function resetFlags() {\n"
	"	flags = {\n"
	"		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated\n"
	"	};\n"
	"}\n"
	"resetFlags(); //init flags on load script\n"
	"\n"
	"// SUPER hacky location... :/\n"
	"var editorDevFlags = {\n"
	"	// NONE right now!\n"
	"};\n"
	"\n"
	"function clearGameData() {\n"
	"	room = {};\n"
	"	tile = {};\n"
	"	sprite = {};\n"
	"	item = {};\n"
	"	dialog = {};\n"
	"	palette = { //start off with a default palette\n"
	"		\"default\" : {\n"
	"			name : \"default\",\n"
	"			colors : [[0,0,0],[255,255,255],[255,255,255]]\n"
	"		}\n"
	"	};\n"
	"	isEnding = false; //todo - correct place for this?\n"
	"	variable = {};\n"
	"\n"
	"	// TODO RENDERER : clear data?\n"
	"\n"
	"	spriteStartLocations = {};\n"
	"\n"
	"	updateNamesFromCurData();\n"
	"\n"
	"	fontName = defaultFontName; // TODO : reset font manager too?\n"
	"	textDirection = TextDirection.LeftToRight;\n"
	"}\n"
	"\n"
	"var width = 128;\n"
	"var height = 128;\n"
	"var scale = 4; //this is stupid but necessary\n"
	"var tilesize = 8;\n"
	"var mapsize = 16;\n"
	"\n"
	"var curRoom = \"0\";\n"
	"\n"
	"var prevTime = 0;\n"
	"var deltaTime = 0;\n"
	"\n"
	"// engine event hooks for the editor\n"
	"var onInventoryChanged = null;\n"
	"var onVariableChanged = null;\n"
	"var onGameReset = null;\n"
	"var onInitRoom = null;\n"
	"\n"
	"var isPlayerEmbeddedInEditor = false;\n"
	"\n"
	"var renderer = new TileRenderer(tilesize);\n"
	"\n"
	"var curGameData = null;\n"
	"var curDefaultFontData = null;\n"
	"\n"
	"function load_game(gameData, defaultFontData, startWithTitle) {\n"
	"	curGameData = gameData; //remember the current game (used to reset the game)\n"
	"\n"
	"	dialogBuffer.Reset();\n"
	"	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?\n"
	"\n"
	"	parseWorld(gameData);\n"
	"\n"
	"	if (!isPlayerEmbeddedInEditor && defaultFontData) {\n"
	"		curDefaultFontData = defaultFontData; // store for resetting game\n"
	"\n"
	"		// todo : consider replacing this with a more general system for requesting resources from the system?\n"
	"		// hack to ensure default font is available\n"
	"		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);\n"
	"	}\n"
	"\n"
	"	var font = fontManager.Get( fontName );\n"
	"	dialogBuffer.SetFont(font);\n"
	"	dialogRenderer.SetFont(font);\n"
	"\n"
	"	setInitialVariables();\n"
	"\n"
	"	onready(startWithTitle);\n"
	"}\n"
	"\n"
	"function reset_cur_game() {\n"
	"	if (curGameData == null) {\n"
	"		return; //can't reset if we don't have the game data\n"
	"	}\n"
	"\n"
	"	stopGame();\n"
	"	clearGameData();\n"
	"	load_game(curGameData, curDefaultFontData);\n"
	"\n"
	"	if (isPlayerEmbeddedInEditor && onGameReset != null) {\n"
	"		onGameReset();\n"
	"	}\n"
	"}\n"
	"\n"
	"function onready(startWithTitle) {\n"
	"	if (startWithTitle === undefined || startWithTitle === null) {\n"
	"		startWithTitle = true;\n"
	"	}\n"
	"\n"
	"	if (startWithTitle) { // used by editor \n"
	"		startNarrating(getTitle());\n"
	"	}\n"
	"}\n"
	"\n"
	"function setInitialVariables() {\n"
	"	for(id in variable) {\n"
	"		var value = variable[id]; // default to string\n"
	"		if(value === \"true\") {\n"
	"			value = true;\n"
	"		}\n"
	"		else if(value === \"false\") {\n"
	"			value = false;\n"
	"		}\n"
	"		else if(!isNaN(parseFloat(value))) {\n"
	"			value = parseFloat(value);\n"
	"		}\n"
	"		scriptInterpreter.SetVariable(id,value);\n"
	"	}\n"
	"	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );\n"
	"}\n"
	"\n"
	"function getOffset(evt) {\n"
	"	var offset = { x:0, y:0 };\n"
	"\n"
	"	var el = evt.target;\n"
	"	var rect = el.getBoundingClientRect();\n"
	"\n"
	"	offset.x += rect.left + el.scrollLeft;\n"
	"	offset.y += rect.top + el.scrollTop;\n"
	"\n"
	"	offset.x = evt.clientX - offset.x;\n"
	"	offset.y = evt.clientY - offset.y;\n"
	"\n"
	"	return offset;\n"
	"}\n"
	"\n"
	"function stopGame() {\n"
	"	bitsyLog(\"stop GAME!\");\n"
	"}\n"
	"\n"
	"function update() {\n"
	"	var curTime = Date.now();\n"
	"	deltaTime = curTime - prevTime;\n"
	"\n"
	"	if (curRoom == null) {\n"
	"		// in the special case where there is no valid room, end the game\n"
	"		startNarrating( \"\", true /*isEnding*/ );\n"
	"	}\n"
	"\n"
	"	if (!transition.IsTransitionActive()) {\n"
	"		updateInput();\n"
	"	}\n"
	"\n"
	"	if (transition.IsTransitionActive()) {\n"
	"		// transition animation takes over everything!\n"
	"		transition.UpdateTransition(deltaTime);\n"
	"	}\n"
	"	else {\n"
	"		bitsySetGraphicsMode(1);\n"
	"\n"
	"		if (!isNarrating && !isEnding) {\n"
	"			updateAnimation();\n"
	"			drawRoom(room[curRoom]); // draw world if game has begun\n"
	"		}\n"
	"		else {\n"
	"			clearRoom();\n"
	"		}\n"
	"\n"
	"		// if (isDialogMode) { // dialog mode\n"
	"		if(dialogBuffer.IsActive()) {\n"
	"			dialogRenderer.Draw( dialogBuffer, deltaTime );\n"
	"			dialogBuffer.Update( deltaTime );\n"
	"		}\n"
	"\n"
	"		// keep moving avatar if player holds down button\n"
	"		if( !dialogBuffer.IsActive() && !isEnding )\n"
	"		{\n"
	"			if( curPlayerDirection != Direction.None ) {\n"
	"				playerHoldToMoveTimer -= deltaTime;\n"
	"\n"
	"				if( playerHoldToMoveTimer <= 0 )\n"
	"				{\n"
	"					movePlayer( curPlayerDirection );\n"
	"					playerHoldToMoveTimer = 150;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	prevTime = curTime;\n"
	"}\n"
	"\n"
	"var isAnyButtonHeld = false;\n"
	"var isIgnoringInput = false;\n"
	"\n"
	"function isAnyButtonDown() {\n"
	"	return bitsyGetButton(0) || bitsyGetButton(1) || bitsyGetButton(2) || bitsyGetButton(3) || bitsyGetButton(4);\n"
	"}\n"
	"\n"
	"function updateInput() {\n"
	"	if (dialogBuffer.IsActive()) {\n"
	"		if (!isAnyButtonHeld && isAnyButtonDown()) {\n"
	"			/* CONTINUE DIALOG */\n"
	"			if (dialogBuffer.CanContinue()) {\n"
	"				var hasMoreDialog = dialogBuffer.Continue();\n"
	"				if (!hasMoreDialog) {\n"
	"					// ignore currently held keys UNTIL they are released (stops player from insta-moving)\n"
	"					isIgnoringInput = true;\n"
	"					curPlayerDirection = Direction.None;\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				dialogBuffer.Skip();\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"	else if (isEnding) {\n"
	"		if (!isAnyButtonHeld && isAnyButtonDown()) {\n"
	"			/* RESTART GAME */\n"
	"			reset_cur_game();\n"
	"		}\n"
	"	}\n"
	"	else if (!isIgnoringInput) {\n"
	"		/* WALK */\n"
	"		var prevPlayerDirection = curPlayerDirection;\n"
	"\n"
	"		if (bitsyGetButton(0)) {\n"
	"			curPlayerDirection = Direction.Up;\n"
	"		}\n"
	"		else if (bitsyGetButton(1)) {\n"
	"			curPlayerDirection = Direction.Down;\n"
	"		}\n"
	"		else if (bitsyGetButton(2)) {\n"
	"			curPlayerDirection = Direction.Left;\n"
	"		}\n"
	"		else if (bitsyGetButton(3)) {\n"
	"			curPlayerDirection = Direction.Right;\n"
	"		}\n"
	"		else {\n"
	"			curPlayerDirection = Direction.None;\n"
	"		}\n"
	"\n"
	"		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {\n"
	"			movePlayer(curPlayerDirection);\n"
	"			playerHoldToMoveTimer = 500;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (!isAnyButtonDown()) {\n"
	"		isIgnoringInput = false;\n"
	"	}\n"
	"\n"
	"	isAnyButtonHeld = isAnyButtonDown();\n"
	"}\n"
	"\n"
	"var animationCounter = 0;\n"
	"var animationTime = 400;\n"
	"function updateAnimation() {\n"
	"	animationCounter += deltaTime;\n"
	"\n"
	"	if ( animationCounter >= animationTime ) {\n"
	"\n"
	"		// animate sprites\n"
	"		for (id in sprite) {\n"
	"			var spr = sprite[id];\n"
	"			if (spr.animation.isAnimated) {\n"
	"				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// animate tiles\n"
	"		for (id in tile) {\n"
	"			var til = tile[id];\n"
	"			if (til.animation.isAnimated) {\n"
	"				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// animate items\n"
	"		for (id in item) {\n"
	"			var itm = item[id];\n"
	"			if (itm.animation.isAnimated) {\n"
	"				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// reset counter\n"
	"		animationCounter = 0;\n"
	"\n"
	"	}\n"
	"}\n"
	"\n"
	"function resetAllAnimations() {\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (spr.animation.isAnimated) {\n"
	"			spr.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	for (id in tile) {\n"
	"		var til = tile[id];\n"
	"		if (til.animation.isAnimated) {\n"
	"			til.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	for (id in item) {\n"
	"		var itm = item[id];\n"
	"		if (itm.animation.isAnimated) {\n"
	"			itm.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function getSpriteAt(x,y) {\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (spr.room === curRoom) {\n"
	"			if (spr.x == x && spr.y == y) {\n"
	"				return id;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"var Direction = {\n"
	"	None : -1,\n"
	"	Up : 0,\n"
	"	Down : 1,\n"
	"	Left : 2,\n"
	"	Right : 3\n"
	"};\n"
	"\n"
	"var curPlayerDirection = Direction.None;\n"
	"var playerHoldToMoveTimer = 0;\n"
	"\n"
	"function movePlayer(direction) {\n"
	"	var roomIds = Object.keys(room);\n"
	"\n"
	"	if (player().room == null || roomIds.indexOf(player().room) < 0) {\n"
	"		return; // player room is missing or invalid.. can't move them!\n"
	"	}\n"
	"\n"
	"	var spr = null;\n"
	"\n"
	"	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {\n"
	"		player().x -= 1;\n"
	"	}\n"
	"	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {\n"
	"		player().x += 1;\n"
	"	}\n"
	"	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {\n"
	"		player().y -= 1;\n"
	"	}\n"
	"	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {\n"
	"		player().y += 1;\n"
	"	}\n"
	"	\n"
	"	var ext = getExit( player().room, player().x, player().y );\n"
	"	var end = getEnding( player().room, player().x, player().y );\n"
	"	var itmIndex = getItemIndex( player().room, player().x, player().y );\n"
	"\n"
	"	// do items first, because you can pick up an item AND go through a door\n"
	"	if (itmIndex > -1) {\n"
	"		var itm = room[player().room].items[itmIndex];\n"
	"		var itemRoom = player().room;\n"
	"\n"
	"		startItemDialog(itm.id, function() {\n"
	"			// remove item from room\n"
	"			room[itemRoom].items.splice(itmIndex, 1);\n"
	"\n"
	"			// update player inventory\n"
	"			if (player().inventory[itm.id]) {\n"
	"				player().inventory[itm.id] += 1;\n"
	"			}\n"
	"			else {\n"
	"				player().inventory[itm.id] = 1;\n"
	"			}\n"
	"\n"
	"			// show inventory change in UI\n"
	"			if (onInventoryChanged != null) {\n"
	"				onInventoryChanged(itm.id);\n"
	"			}\n"
	"		});\n"
	"	}\n"
	"\n"
	"	if (end) {\n"
	"		startEndingDialog(end);\n"
	"	}\n"
	"	else if (ext) {\n"
	"		movePlayerThroughExit(ext);\n"
	"	}\n"
	"	else if (spr) {\n"
	"		startSpriteDialog(spr /*spriteId*/);\n"
	"	}\n"
	"}\n"
	"\n"
	"var transition = new TransitionManager();\n"
	"\n"
	"function movePlayerThroughExit(ext) {\n"
	"	var GoToDest = function() {\n"
	"		if (ext.transition_effect != null) {\n"
	"			transition.BeginTransition(\n"
	"				player().room,\n"
	"				player().x,\n"
	"				player().y,\n"
	"				ext.dest.room,\n"
	"				ext.dest.x,\n"
	"				ext.dest.y,\n"
	"				ext.transition_effect);\n"
	"\n"
	"			transition.UpdateTransition(0);\n"
	"\n"
	"			transition.OnTransitionComplete(function() {\n"
	"				player().room = ext.dest.room;\n"
	"				player().x = ext.dest.x;\n"
	"				player().y = ext.dest.y;\n"
	"				curRoom = ext.dest.room;\n"
	"\n"
	"				initRoom(curRoom);\n"
	"			});\n"
	"		}\n"
	"		else {\n"
	"			player().room = ext.dest.room;\n"
	"			player().x = ext.dest.x;\n"
	"			player().y = ext.dest.y;\n"
	"			curRoom = ext.dest.room;\n"
	"\n"
	"			initRoom(curRoom);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	if (ext.dlg != undefined && ext.dlg != null) {\n"
	"		// TODO : I need to simplify dialog code,\n"
	"		// so I don't have to get the ID and the source str\n"
	"		// every time!\n"
	"		startDialog(\n"
	"			dialog[ext.dlg].src,\n"
	"			ext.dlg,\n"
	"			function(result) {\n"
	"				var isLocked = ext.property && ext.property.locked === true;\n"
	"				if (!isLocked) {\n"
	"					GoToDest();\n"
	"				}\n"
	"			},\n"
	"			ext);\n"
	"	}\n"
	"	else {\n"
	"		GoToDest();\n"
	"	}\n"
	"}\n"
	"\n"
	"/* PALETTE INDICES */\n"
	"var textBackgroundIndex = 0;\n"
	"var textArrowIndex = 1;\n"
	"var textColorIndex = 2;\n"
	"\n"
	"// precalculated rainbow colors\n"
	"var rainbowColorStartIndex = 3;\n"
	"var rainbowColorCount = 10;\n"
	"var rainbowColors = [\n"
	"	[255,0,0],\n"
	"	[255,217,0],\n"
	"	[78,255,0],\n"
	"	[0,255,125],\n"
	"	[0,192,255],\n"
	"	[0,18,255],\n"
	"	[136,0,255],\n"
	"	[255,0,242],\n"
	"	[255,0,138],\n"
	"	[255,0,61],\n"
	"];\n"
	"\n"
	"// todo : where should this be stored?\n"
	"var tileColorStartIndex = 16;\n"
	"\n"
	"function updatePaletteWithTileColors(tileColors) {\n"
	"	// clear existing colors\n"
	"	bitsyResetColors();\n"
	"\n"
	"	// textbox colors\n"
	"	bitsySetColor(textBackgroundIndex, 0, 0, 0); // black\n"
	"	bitsySetColor(textArrowIndex, 255, 255, 255); // white\n"
	"	bitsySetColor(textColorIndex, 255, 255, 255); // white\n"
	"\n"
	"	// todo : move this to game init?\n"
	"	// rainbow colors\n"
	"	for (var i = 0; i < rainbowColorCount; i++) {\n"
	"		var color = rainbowColors[i];\n"
	"		bitsySetColor(rainbowColorStartIndex + i, color[0], color[1], color[2]);\n"
	"	}\n"
	"\n"
	"	// tile colors\n"
	"	for (var i = 0; i < tileColors.length; i++) {\n"
	"		var color = tileColors[i];\n"
	"		bitsySetColor(tileColorStartIndex + i, color[0], color[1], color[2]);\n"
	"	}\n"
	"}\n"
	"\n"
	"function updatePalette(palId) {\n"
	"	var pal = palette[palId];\n"
	"	bitsyLog(pal.colors.length, \"editor\");\n"
	"	updatePaletteWithTileColors(pal.colors);\n"
	"}\n"
	"\n"
	"function initRoom(roomId) {\n"
	"	bitsyLog(\"init room \" + roomId);\n"
	"\n"
	"	updatePalette(curPal());\n"
	"\n"
	"	renderer.ClearCache();\n"
	"\n"
	"	// init exit properties\n"
	"	for (var i = 0; i < room[roomId].exits.length; i++) {\n"
	"		room[roomId].exits[i].property = { locked:false };\n"
	"	}\n"
	"\n"
	"	// init ending properties\n"
	"	for (var i = 0; i < room[roomId].endings.length; i++) {\n"
	"		room[roomId].endings[i].property = { locked:false };\n"
	"	}\n"
	"\n"
	"	if (onInitRoom) {\n"
	"		onInitRoom(roomId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function getItemIndex( roomId, x, y ) {\n"
	"	for( var i = 0; i < room[roomId].items.length; i++ ) {\n"
	"		var itm = room[roomId].items[i];\n"
	"		if ( itm.x == x && itm.y == y)\n"
	"			return i;\n"
	"	}\n"
	"	return -1;\n"
	"}\n"
	"\n"
	"function getSpriteLeft() { //repetitive?\n"
	"	return getSpriteAt( player().x - 1, player().y );\n"
	"}\n"
	"\n"
	"function getSpriteRight() {\n"
	"	return getSpriteAt( player().x + 1, player().y );\n"
	"}\n"
	"\n"
	"function getSpriteUp() {\n"
	"	return getSpriteAt( player().x, player().y - 1 );\n"
	"}\n"
	"\n"
	"function getSpriteDown() {\n"
	"	return getSpriteAt( player().x, player().y + 1 );\n"
	"}\n"
	"\n"
	"function isWallLeft() {\n"
	"	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );\n"
	"}\n"
	"\n"
	"function isWallRight() {\n"
	"	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );\n"
	"}\n"
	"\n"
	"function isWallUp() {\n"
	"	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );\n"
	"}\n"
	"\n"
	"function isWallDown() {\n"
	"	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );\n"
	"}\n"
	"\n"
	"function isWall(x,y,roomId) {\n"
	"	if(roomId == undefined || roomId == null)\n"
	"		roomId = curRoom;\n"
	"\n"
	"	var tileId = getTile( x, y );\n"
	"\n"
	"	if( tileId === '0' )\n"
	"		return false; // Blank spaces aren't walls, ya doofus\n"
	"\n"
	"	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {\n"
	"		// No wall-state defined: check room-specific walls\n"
	"		var i = room[roomId].walls.indexOf( getTile(x,y) );\n"
	"		return i > -1;\n"
	"	}\n"
	"\n"
	"	// Otherwise, use the tile's own wall-state\n"
	"	return tile[tileId].isWall;\n"
	"}\n"
	"\n"
	"function getItem(roomId,x,y) {\n"
	"	for (i in room[roomId].items) {\n"
	"		var item = room[roomId].items[i];\n"
	"		if (x == item.x && y == item.y) {\n"
	"			return item;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"function getExit(roomId,x,y) {\n"
	"	for (i in room[roomId].exits) {\n"
	"		var e = room[roomId].exits[i];\n"
	"		if (x == e.x && y == e.y) {\n"
	"			return e;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"function getEnding(roomId,x,y) {\n"
	"	for (i in room[roomId].endings) {\n"
	"		var e = room[roomId].endings[i];\n"
	"		if (x == e.x && y == e.y) {\n"
	"			return e;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"function getTile(x,y) {\n"
	"	// bitsyLog(x + \" \" + y);\n"
	"	var t = getRoom().tilemap[y][x];\n"
	"	return t;\n"
	"}\n"
	"\n"
	"function player() {\n"
	"	return sprite[playerId];\n"
	"}\n"
	"\n"
	"// Sort of a hack for legacy palette code (when it was just an array)\n"
	"function getPal(id) {\n"
	"	if (palette[id] === undefined) {\n"
	"		id = \"default\";\n"
	"	}\n"
	"\n"
	"	return palette[ id ].colors;\n"
	"}\n"
	"\n"
	"function getRoom() {\n"
	"	return room[curRoom];\n"
	"}\n"
	"\n"
	"function isSpriteOffstage(id) {\n"
	"	return sprite[id].room == null;\n"
	"}\n"
	"\n"
	"function parseWorld(file) {\n"
	"	spriteStartLocations = {};\n"
	"\n"
	"	resetFlags();\n"
	"\n"
	"	var versionNumber = 0;\n"
	"\n"
	"	// flags to keep track of which compatibility conversions\n"
	"	// need to be applied to this game data\n"
	"	var compatibilityFlags = {\n"
	"		convertSayToPrint : false,\n"
	"		combineEndingsWithDialog : false,\n"
	"		convertImplicitSpriteDialogIds : false,\n"
	"	};\n"
	"\n"
	"	var lines = file.split(\"\\n\");\n"
	"	var i = 0;\n"
	"	while (i < lines.length) {\n"
	"		var curLine = lines[i];\n"
	"\n"
	"		// bitsyLog(lines[i]);\n"
	"\n"
	"		if (i == 0) {\n"
	"			i = parseTitle(lines, i);\n"
	"		}\n"
	"		else if (curLine.length <= 0 || curLine.charAt(0) === \"#\") {\n"
	"			// collect version number (from a comment.. hacky I know)\n"
	"			if (curLine.indexOf(\"# BITSY VERSION \") != -1) {\n"
	"				versionNumber = parseFloat(curLine.replace(\"# BITSY VERSION \", \"\"));\n"
	"\n"
	"				if (versionNumber < 5.0) {\n"
	"					compatibilityFlags.convertSayToPrint = true;\n"
	"				}\n"
	"\n"
	"				if (versionNumber < 7.0) {\n"
	"					compatibilityFlags.combineEndingsWithDialog = true;\n"
	"					compatibilityFlags.convertImplicitSpriteDialogIds = true;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			//skip blank lines & comments\n"
	"			i++;\n"
	"		}\n"
	"		else if (getType(curLine) == \"PAL\") {\n"
	"			i = parsePalette(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"ROOM\" || getType(curLine) === \"SET\") { //SET for back compat\n"
	"			i = parseRoom(lines, i, compatibilityFlags);\n"
	"		}\n"
	"		else if (getType(curLine) === \"TIL\") {\n"
	"			i = parseTile(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"SPR\") {\n"
	"			i = parseSprite(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"ITM\") {\n"
	"			i = parseItem(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"DRW\") {\n"
	"			i = parseDrawing(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"DLG\") {\n"
	"			i = parseDialog(lines, i, compatibilityFlags);\n"
	"		}\n"
	"		else if (getType(curLine) === \"END\" && compatibilityFlags.combineEndingsWithDialog) {\n"
	"			// parse endings for back compat\n"
	"			i = parseEnding(lines, i, compatibilityFlags);\n"
	"		}\n"
	"		else if (getType(curLine) === \"VAR\") {\n"
	"			i = parseVariable(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"DEFAULT_FONT\") {\n"
	"			i = parseFontName(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"TEXT_DIRECTION\") {\n"
	"			i = parseTextDirection(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"FONT\") {\n"
	"			i = parseFontData(lines, i);\n"
	"		}\n"
	"		else if (getType(curLine) === \"!\") {\n"
	"			i = parseFlag(lines, i);\n"
	"		}\n"
	"		else {\n"
	"			i++;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	placeSprites();\n"
	"\n"
	"	var roomIds = Object.keys(room);\n"
	"\n"
	"	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {\n"
	"		// player has valid room\n"
	"		curRoom = player().room;\n"
	"	}\n"
	"	else if (roomIds.length > 0) {\n"
	"		// player not in any room! what the heck\n"
	"		curRoom = roomIds[0];\n"
	"	}\n"
	"	else {\n"
	"		// uh oh there are no rooms I guess???\n"
	"		curRoom = null;\n"
	"	}\n"
	"\n"
	"	if (curRoom != null) {\n"
	"		initRoom(curRoom);\n"
	"	}\n"
	"\n"
	"	scriptCompatibility(compatibilityFlags);\n"
	"\n"
	"	return versionNumber;\n"
	"}\n"
	"\n"
	"function scriptCompatibility(compatibilityFlags) {\n"
	"	if (compatibilityFlags.convertSayToPrint) {\n"
	"		bitsyLog(\"CONVERT SAY TO PRINT!\");\n"
	"\n"
	"		var PrintFunctionVisitor = function() {\n"
	"			var didChange = false;\n"
	"			this.DidChange = function() { return didChange; };\n"
	"\n"
	"			this.Visit = function(node) {\n"
	"				if (node.type != \"function\") {\n"
	"					return;\n"
	"				}\n"
	"\n"
	"				if (node.name === \"say\") {\n"
	"					node.name = \"print\";\n"
	"					didChange = true;\n"
	"				}\n"
	"			};\n"
	"		};\n"
	"\n"
	"		for (dlgId in dialog) {\n"
	"			var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);\n"
	"			var visitor = new PrintFunctionVisitor();\n"
	"			dialogScript.VisitAll(visitor);\n"
	"			if (visitor.DidChange()) {\n"
	"				var newDialog = dialogScript.Serialize();\n"
	"				if (newDialog.indexOf(\"\\n\") > -1) {\n"
	"					newDialog = '\"\"\"\\n' + newDialog + '\\n\"\"\"';\n"
	"				}\n"
	"				dialog[dlgId].src = newDialog;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"//TODO this is in progress and doesn't support all features\n"
	"function serializeWorld(skipFonts) {\n"
	"	if (skipFonts === undefined || skipFonts === null)\n"
	"		skipFonts = false;\n"
	"\n"
	"	var worldStr = \"\";\n"
	"	/* TITLE */\n"
	"	worldStr += getTitle() + \"\\n\";\n"
	"	worldStr += \"\\n\";\n"
	"	/* VERSION */\n"
	"	worldStr += \"# BITSY VERSION \" + getEngineVersion() + \"\\n\"; // add version as a comment for debugging purposes\n"
	"	if (version.devBuildPhase != \"RELEASE\") {\n"
	"		worldStr += \"# DEVELOPMENT BUILD -- \" + version.devBuildPhase;\n"
	"	}\n"
	"	worldStr += \"\\n\";\n"
	"	/* FLAGS */\n"
	"	for (f in flags) {\n"
	"		worldStr += \"! \" + f + \" \" + flags[f] + \"\\n\";\n"
	"	}\n"
	"	worldStr += \"\\n\"\n"
	"	/* FONT */\n"
	"	if (fontName != defaultFontName) {\n"
	"		worldStr += \"DEFAULT_FONT \" + fontName + \"\\n\";\n"
	"		worldStr += \"\\n\"\n"
	"	}\n"
	"	if (textDirection != TextDirection.LeftToRight) {\n"
	"		worldStr += \"TEXT_DIRECTION \" + textDirection + \"\\n\";\n"
	"		worldStr += \"\\n\"\n"
	"	}\n"
	"	/* PALETTE */\n"
	"	for (id in palette) {\n"
	"		if (id != \"default\") {\n"
	"			worldStr += \"PAL \" + id + \"\\n\";\n"
	"			if( palette[id].name != null )\n"
	"				worldStr += \"NAME \" + palette[id].name + \"\\n\";\n"
	"			for (i in getPal(id)) {\n"
	"				for (j in getPal(id)[i]) {\n"
	"					worldStr += getPal(id)[i][j];\n"
	"					if (j < 2) worldStr += \",\";\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"	}\n"
	"	/* ROOM */\n"
	"	for (id in room) {\n"
	"		worldStr += \"ROOM \" + id + \"\\n\";\n"
	"		if ( flags.ROOM_FORMAT == 0 ) {\n"
	"			// old non-comma separated format\n"
	"			for (i in room[id].tilemap) {\n"
	"				for (j in room[id].tilemap[i]) {\n"
	"					worldStr += room[id].tilemap[i][j];	\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		else if ( flags.ROOM_FORMAT == 1 ) {\n"
	"			// new comma separated format\n"
	"			for (i in room[id].tilemap) {\n"
	"				for (j in room[id].tilemap[i]) {\n"
	"					worldStr += room[id].tilemap[i][j];\n"
	"					if (j < room[id].tilemap[i].length-1) worldStr += \",\"\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].name != null) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + room[id].name + \"\\n\";\n"
	"		}\n"
	"		if (room[id].walls.length > 0) {\n"
	"			/* WALLS */\n"
	"			worldStr += \"WAL \";\n"
	"			for (j in room[id].walls) {\n"
	"				worldStr += room[id].walls[j];\n"
	"				if (j < room[id].walls.length-1) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"		if (room[id].items.length > 0) {\n"
	"			/* ITEMS */\n"
	"			for (j in room[id].items) {\n"
	"				var itm = room[id].items[j];\n"
	"				worldStr += \"ITM \" + itm.id + \" \" + itm.x + \",\" + itm.y;\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].exits.length > 0) {\n"
	"			/* EXITS */\n"
	"			for (j in room[id].exits) {\n"
	"				var e = room[id].exits[j];\n"
	"				if ( isExitValid(e) ) {\n"
	"					worldStr += \"EXT \" + e.x + \",\" + e.y + \" \" + e.dest.room + \" \" + e.dest.x + \",\" + e.dest.y;\n"
	"					if (e.transition_effect != undefined && e.transition_effect != null) {\n"
	"						worldStr += \" FX \" + e.transition_effect;\n"
	"					}\n"
	"					if (e.dlg != undefined && e.dlg != null) {\n"
	"						worldStr += \" DLG \" + e.dlg;\n"
	"					}\n"
	"					worldStr += \"\\n\";\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		if (room[id].endings.length > 0) {\n"
	"			/* ENDINGS */\n"
	"			for (j in room[id].endings) {\n"
	"				var e = room[id].endings[j];\n"
	"				// todo isEndingValid\n"
	"				worldStr += \"END \" + e.id + \" \" + e.x + \",\" + e.y;\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].pal != null && room[id].pal != \"default\") {\n"
	"			/* PALETTE */\n"
	"			worldStr += \"PAL \" + room[id].pal + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* TILES */\n"
	"	for (id in tile) {\n"
	"		worldStr += \"TIL \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"TIL_\" + id );\n"
	"		if (tile[id].name != null && tile[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + tile[id].name + \"\\n\";\n"
	"		}\n"
	"		if (tile[id].isWall != null && tile[id].isWall != undefined) {\n"
	"			/* WALL */\n"
	"			worldStr += \"WAL \" + tile[id].isWall + \"\\n\";\n"
	"		}\n"
	"		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + tile[id].col + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* SPRITES */\n"
	"	for (id in sprite) {\n"
	"		worldStr += \"SPR \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"SPR_\" + id );\n"
	"		if (sprite[id].name != null && sprite[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + sprite[id].name + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].dlg != null) {\n"
	"			worldStr += \"DLG \" + sprite[id].dlg + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].room != null) {\n"
	"			/* SPRITE POSITION */\n"
	"			worldStr += \"POS \" + sprite[id].room + \" \" + sprite[id].x + \",\" + sprite[id].y + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].inventory != null) {\n"
	"			for(itemId in sprite[id].inventory) {\n"
	"				worldStr += \"ITM \" + itemId + \" \" + sprite[id].inventory[itemId] + \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + sprite[id].col + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* ITEMS */\n"
	"	for (id in item) {\n"
	"		worldStr += \"ITM \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"ITM_\" + id );\n"
	"		if (item[id].name != null && item[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + item[id].name + \"\\n\";\n"
	"		}\n"
	"		if (item[id].dlg != null) {\n"
	"			worldStr += \"DLG \" + item[id].dlg + \"\\n\";\n"
	"		}\n"
	"		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + item[id].col + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* DIALOG */\n"
	"	for (id in dialog) {\n"
	"		if (id != titleDialogId) {\n"
	"			worldStr += \"DLG \" + id + \"\\n\";\n"
	"			worldStr += dialog[id].src + \"\\n\";\n"
	"			if (dialog[id].name != null) {\n"
	"				worldStr += \"NAME \" + dialog[id].name + \"\\n\";\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"	}\n"
	"	/* VARIABLES */\n"
	"	for (id in variable) {\n"
	"		worldStr += \"VAR \" + id + \"\\n\";\n"
	"		worldStr += variable[id] + \"\\n\";\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* FONT */\n"
	"	// TODO : support multiple fonts\n"
	"	if (fontName != defaultFontName && !skipFonts) {\n"
	"		worldStr += fontManager.GetData(fontName);\n"
	"	}\n"
	"\n"
	"	return worldStr;\n"
	"}\n"
	"\n"
	"function serializeDrawing(drwId) {\n"
	"	var drawingData = renderer.GetDrawingSource(drwId);\n"
	"	var drwStr = \"\";\n"
	"	for (f in drawingData) {\n"
	"		for (y in drawingData[f]) {\n"
	"			var rowStr = \"\";\n"
	"			for (x in drawingData[f][y]) {\n"
	"				rowStr += drawingData[f][y][x];\n"
	"			}\n"
	"			drwStr += rowStr + \"\\n\";\n"
	"		}\n"
	"		if (f < (drawingData.length-1)) drwStr += \">\\n\";\n"
	"	}\n"
	"	return drwStr;\n"
	"}\n"
	"\n"
	"function isExitValid(e) {\n"
	"	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;\n"
	"	var hasDest = e.dest != null;\n"
	"	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);\n"
	"	return hasValidStartPos && hasDest && hasValidRoomDest;\n"
	"}\n"
	"\n"
	"function placeSprites() {\n"
	"	for (id in spriteStartLocations) {\n"
	"		//bitsyLog(id);\n"
	"		//bitsyLog( spriteStartLocations[id] );\n"
	"		//bitsyLog(sprite[id]);\n"
	"		sprite[id].room = spriteStartLocations[id].room;\n"
	"		sprite[id].x = spriteStartLocations[id].x;\n"
	"		sprite[id].y = spriteStartLocations[id].y;\n"
	"		//bitsyLog(sprite[id]);\n"
	"	}\n"
	"}\n"
	"\n"
	"/* ARGUMENT GETTERS */\n"
	"function getType(line) {\n"
	"	return getArg(line,0);\n"
	"}\n"
	"\n"
	"function getId(line) {\n"
	"	return getArg(line,1);\n"
	"}\n"
	"\n"
	"function getArg(line,arg) {\n"
	"	return line.split(\" \")[arg];\n"
	"}\n"
	"\n"
	"function getCoord(line,arg) {\n"
	"	return getArg(line,arg).split(\",\");\n"
	"}\n"
	"\n"
	"function parseTitle(lines, i) {\n"
	"	var results = scriptUtils.ReadDialogScript(lines,i);\n"
	"	setTitle(results.script);\n"
	"	i = results.index;\n"
	"\n"
	"	i++;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseRoom(lines, i, compatibilityFlags) {\n"
	"	var id = getId(lines[i]);\n"
	"	room[id] = {\n"
	"		id : id,\n"
	"		tilemap : [],\n"
	"		walls : [],\n"
	"		exits : [],\n"
	"		endings : [],\n"
	"		items : [],\n"
	"		pal : null,\n"
	"		name : null\n"
	"	};\n"
	"	i++;\n"
	"\n"
	"	// create tile map\n"
	"	if ( flags.ROOM_FORMAT == 0 ) {\n"
	"		// old way: no commas, single char tile ids\n"
	"		var end = i + mapsize;\n"
	"		var y = 0;\n"
	"		for (; i<end; i++) {\n"
	"			room[id].tilemap.push( [] );\n"
	"			for (x = 0; x<mapsize; x++) {\n"
	"				room[id].tilemap[y].push( lines[i].charAt(x) );\n"
	"			}\n"
	"			y++;\n"
	"		}\n"
	"	}\n"
	"	else if ( flags.ROOM_FORMAT == 1 ) {\n"
	"		// new way: comma separated, multiple char tile ids\n"
	"		var end = i + mapsize;\n"
	"		var y = 0;\n"
	"		for (; i<end; i++) {\n"
	"			room[id].tilemap.push( [] );\n"
	"			var lineSep = lines[i].split(\",\");\n"
	"			for (x = 0; x<mapsize; x++) {\n"
	"				room[id].tilemap[y].push( lineSep[x] );\n"
	"			}\n"
	"			y++;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	while (i < lines.length && lines[i].length > 0) { //look for empty line\n"
	"		// bitsyLog(getType(lines[i]));\n"
	"		if (getType(lines[i]) === \"SPR\") {\n"
	"			/* NOTE SPRITE START LOCATIONS */\n"
	"			var sprId = getId(lines[i]);\n"
	"			if (sprId.indexOf(\",\") == -1 && lines[i].split(\" \").length >= 3) { //second conditional checks for coords\n"
	"				/* PLACE A SINGLE SPRITE */\n"
	"				var sprCoord = lines[i].split(\" \")[2].split(\",\");\n"
	"				spriteStartLocations[sprId] = {\n"
	"					room : id,\n"
	"					x : parseInt(sprCoord[0]),\n"
	"					y : parseInt(sprCoord[1])\n"
	"				};\n"
	"			}\n"
	"			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format\n"
	"				/* PLACE MULTIPLE SPRITES*/ \n"
	"				//Does find and replace in the tilemap (may be hacky, but its convenient)\n"
	"				var sprList = sprId.split(\",\");\n"
	"				for (row in room[id].tilemap) {\n"
	"					for (s in sprList) {\n"
	"						var col = room[id].tilemap[row].indexOf( sprList[s] );\n"
	"						//if the sprite is in this row, replace it with the \"null tile\" and set its starting position\n"
	"						if (col != -1) {\n"
	"							room[id].tilemap[row][col] = \"0\";\n"
	"							spriteStartLocations[ sprList[s] ] = {\n"
	"								room : id,\n"
	"								x : parseInt(col),\n"
	"								y : parseInt(row)\n"
	"							};\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"ITM\") {\n"
	"			var itmId = getId(lines[i]);\n"
	"			var itmCoord = lines[i].split(\" \")[2].split(\",\");\n"
	"			var itm = {\n"
	"				id: itmId,\n"
	"				x : parseInt(itmCoord[0]),\n"
	"				y : parseInt(itmCoord[1])\n"
	"			};\n"
	"			room[id].items.push( itm );\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"WAL\") {\n"
	"			/* DEFINE COLLISIONS (WALLS) */\n"
	"			room[id].walls = getId(lines[i]).split(\",\");\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"EXT\") {\n"
	"			/* ADD EXIT */\n"
	"			var exitArgs = lines[i].split(\" \");\n"
	"			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]\n"
	"			var exitCoords = exitArgs[1].split(\",\");\n"
	"			var destName = exitArgs[2];\n"
	"			var destCoords = exitArgs[3].split(\",\");\n"
	"			var ext = {\n"
	"				x : parseInt(exitCoords[0]),\n"
	"				y : parseInt(exitCoords[1]),\n"
	"				dest : {\n"
	"					room : destName,\n"
	"					x : parseInt(destCoords[0]),\n"
	"					y : parseInt(destCoords[1])\n"
	"				},\n"
	"				transition_effect : null,\n"
	"				dlg: null,\n"
	"			};\n"
	"\n"
	"			// optional arguments\n"
	"			var exitArgIndex = 4;\n"
	"			while (exitArgIndex < exitArgs.length) {\n"
	"				if (exitArgs[exitArgIndex] == \"FX\") {\n"
	"					ext.transition_effect = exitArgs[exitArgIndex+1];\n"
	"					exitArgIndex += 2;\n"
	"				}\n"
	"				else if (exitArgs[exitArgIndex] == \"DLG\") {\n"
	"					ext.dlg = exitArgs[exitArgIndex+1];\n"
	"					exitArgIndex += 2;\n"
	"				}\n"
	"				else {\n"
	"					exitArgIndex += 1;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			room[id].exits.push(ext);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"END\") {\n"
	"			/* ADD ENDING */\n"
	"			var endId = getId(lines[i]);\n"
	"\n"
	"			// compatibility with when endings were stored separate from other dialog\n"
	"			if (compatibilityFlags.combineEndingsWithDialog) {\n"
	"				endId = \"end_\" + endId;\n"
	"			}\n"
	"\n"
	"			var endCoords = getCoord(lines[i], 2);\n"
	"			var end = {\n"
	"				id : endId,\n"
	"				x : parseInt(endCoords[0]),\n"
	"				y : parseInt(endCoords[1])\n"
	"			};\n"
	"\n"
	"			room[id].endings.push(end);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"PAL\") {\n"
	"			/* CHOOSE PALETTE (that's not default) */\n"
	"			room[id].pal = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			var name = lines[i].split(/\\s(.+)/)[1];\n"
	"			room[id].name = name;\n"
	"			names.room[name] = id;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parsePalette(lines,i) { //todo this has to go first right now :(\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"	var colors = [];\n"
	"	var name = null;\n"
	"	while (i < lines.length && lines[i].length > 0) { //look for empty line\n"
	"		var args = lines[i].split(\" \");\n"
	"		if (args[0] === \"NAME\") {\n"
	"			name = lines[i].split(/\\s(.+)/)[1];\n"
	"		}\n"
	"		else {\n"
	"			var col = [];\n"
	"			lines[i].split(\",\").forEach(function(i) {\n"
	"				col.push(parseInt(i));\n"
	"			});\n"
	"			colors.push(col);\n"
	"		}\n"
	"		i++;\n"
	"	}\n"
	"	palette[id] = {\n"
	"		id : id,\n"
	"		name : name,\n"
	"		colors : colors\n"
	"	};\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseTile(lines, i) {\n"
	"	var id = getId(lines[i]);\n"
	"	var tileData = createDrawingData(\"TIL\", id);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store tile image source\n"
	"	i = parseDrawingCore(lines, i, tileData.drw);\n"
	"\n"
	"	// update animation info\n"
	"	tileData.animation.frameCount = renderer.GetFrameCount(tileData.drw);\n"
	"	tileData.animation.isAnimated = tileData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			tileData.col = parseInt(getId(lines[i]));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			tileData.name = lines[i].split(/\\s(.+)/)[1];\n"
	"			names.tile[tileData.name] = id;\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"WAL\") {\n"
	"			var wallArg = getArg(lines[i], 1);\n"
	"			if (wallArg === \"true\") {\n"
	"				tileData.isWall = true;\n"
	"			}\n"
	"			else if (wallArg === \"false\") {\n"
	"				tileData.isWall = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store tile data\n"
	"	tile[id] = tileData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseSprite(lines, i) {\n"
	"	var id = getId(lines[i]);\n"
	"	var type = (id === \"A\") ? \"AVA\" : \"SPR\";\n"
	"	var spriteData = createDrawingData(type, id);\n"
	"\n"
	"	bitsyLog(spriteData);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store sprite image source\n"
	"	i = parseDrawingCore(lines, i, spriteData.drw);\n"
	"\n"
	"	// update animation info\n"
	"	spriteData.animation.frameCount = renderer.GetFrameCount(spriteData.drw);\n"
	"	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			/* COLOR OFFSET INDEX */\n"
	"			spriteData.col = parseInt(getId(lines[i]));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"POS\") {\n"
	"			/* STARTING POSITION */\n"
	"			var posArgs = lines[i].split(\" \");\n"
	"			var roomId = posArgs[1];\n"
	"			var coordArgs = posArgs[2].split(\",\");\n"
	"			spriteStartLocations[id] = {\n"
	"				room : roomId,\n"
	"				x : parseInt(coordArgs[0]),\n"
	"				y : parseInt(coordArgs[1])\n"
	"			};\n"
	"		}\n"
	"		else if(getType(lines[i]) === \"DLG\") {\n"
	"			spriteData.dlg = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			spriteData.name = lines[i].split(/\\s(.+)/)[1];\n"
	"			names.sprite[spriteData.name] = id;\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"ITM\") {\n"
	"			/* ITEM STARTING INVENTORY */\n"
	"			var itemId = getId(lines[i]);\n"
	"			var itemCount = parseFloat(getArg(lines[i], 2));\n"
	"			spriteData.inventory[itemId] = itemCount;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store sprite data\n"
	"	sprite[id] = spriteData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseItem(lines, i) {\n"
	"	var id = getId(lines[i]);\n"
	"	var itemData = createDrawingData(\"ITM\", id);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store item image source\n"
	"	i = parseDrawingCore(lines, i, itemData.drw);\n"
	"\n"
	"	// update animation info\n"
	"	itemData.animation.frameCount = renderer.GetFrameCount(itemData.drw);\n"
	"	itemData.animation.isAnimated = itemData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			/* COLOR OFFSET INDEX */\n"
	"			itemData.col = parseInt(getArg(lines[i], 1));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"DLG\") {\n"
	"			itemData.dlg = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			itemData.name = lines[i].split(/\\s(.+)/)[1];\n"
	"			names.item[itemData.name] = id;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store item data\n"
	"	item[id] = itemData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseDrawing(lines, i) {\n"
	"	// store drawing source\n"
	"	var drwId = getId( lines[i] );\n"
	"	return parseDrawingCore( lines, i, drwId );\n"
	"}\n"
	"\n"
	"function parseDrawingCore(lines, i, drwId) {\n"
	"	var frameList = []; //init list of frames\n"
	"	frameList.push( [] ); //init first frame\n"
	"	var frameIndex = 0;\n"
	"	var y = 0;\n"
	"	while ( y < tilesize ) {\n"
	"		var l = lines[i+y];\n"
	"		var row = [];\n"
	"		for (x = 0; x < tilesize; x++) {\n"
	"			row.push( parseInt( l.charAt(x) ) );\n"
	"		}\n"
	"		frameList[frameIndex].push( row );\n"
	"		y++;\n"
	"\n"
	"		if (y === tilesize) {\n"
	"			i = i + y;\n"
	"			if ( lines[i] != undefined && lines[i].charAt(0) === \">\" ) {\n"
	"				// start next frame!\n"
	"				frameList.push( [] );\n"
	"				frameIndex++;\n"
	"				//start the count over again for the next frame\n"
	"				i++;\n"
	"				y = 0;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	renderer.SetDrawingSource(drwId, frameList);\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"// creates a drawing data structure with default property values for the type\n"
	"function createDrawingData(type, id) {\n"
	"	// the avatar's drawing id still uses the sprite prefix (for back compat)\n"
	"	var drwId = (type === \"AVA\" ? \"SPR\" : type) + \"_\" + id;\n"
	"\n"
	"	var drawingData = {\n"
	"		type : type,\n"
	"		id : id,\n"
	"		name : null,\n"
	"		drw : drwId,\n"
	"		col : (type === \"TIL\") ? 1 : 2,\n"
	"		animation : {\n"
	"			isAnimated : false,\n"
	"			frameIndex : 0,\n"
	"			frameCount : 1,\n"
	"		},\n"
	"	};\n"
	"\n"
	"	// add type specific properties\n"
	"	if (type === \"TIL\") {\n"
	"		// default null value indicates it can vary from room to room (original version)\n"
	"		drawingData.isWall = null;\n"
	"	}\n"
	"\n"
	"	if (type === \"AVA\" || type === \"SPR\") {\n"
	"		// default sprite location is \"offstage\"\n"
	"		drawingData.room = null;\n"
	"		drawingData.x = -1;\n"
	"		drawingData.y = -1;\n"
	"		drawingData.inventory = {};\n"
	"	}\n"
	"\n"
	"	if (type === \"AVA\" || type === \"SPR\" || type === \"ITM\") {\n"
	"		drawingData.dlg = null;\n"
	"	}\n"
	"\n"
	"	return drawingData;\n"
	"}\n"
	"\n"
	"function parseScript(lines, i, backCompatPrefix, compatibilityFlags) {\n"
	"	var id = getId(lines[i]);\n"
	"	id = backCompatPrefix + id;\n"
	"	i++;\n"
	"\n"
	"	var results = scriptUtils.ReadDialogScript(lines,i);\n"
	"\n"
	"	dialog[id] = { src: results.script, name: null, id: id, };\n"
	"\n"
	"	if (compatibilityFlags.convertImplicitSpriteDialogIds) {\n"
	"		// explicitly hook up dialog that used to be implicitly\n"
	"		// connected by sharing sprite and dialog IDs in old versions\n"
	"		if (sprite[id]) {\n"
	"			if (sprite[id].dlg === undefined || sprite[id].dlg === null) {\n"
	"				sprite[id].dlg = id;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	i = results.index;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseDialog(lines, i, compatibilityFlags) {\n"
	"	// hacky but I need to store this so I can set the name below\n"
	"	var id = getId(lines[i]);\n"
	"\n"
	"	i = parseScript(lines, i, \"\", compatibilityFlags);\n"
	"\n"
	"	if (lines[i].length > 0 && getType(lines[i]) === \"NAME\") {\n"
	"		dialog[id].name = lines[i].split(/\\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...\n"
	"		names.dialog[dialog[id].name] = id;\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"// keeping this around to parse old files where endings were separate from dialogs\n"
	"function parseEnding(lines, i, compatibilityFlags) {\n"
	"	return parseScript(lines, i, \"end_\", compatibilityFlags);\n"
	"}\n"
	"\n"
	"function parseVariable(lines, i) {\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"	var value = lines[i];\n"
	"	i++;\n"
	"	variable[id] = value;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseFontName(lines, i) {\n"
	"	fontName = getArg(lines[i], 1);\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseTextDirection(lines, i) {\n"
	"	textDirection = getArg(lines[i], 1);\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseFontData(lines, i) {\n"
	"	// NOTE : we're not doing the actual parsing here --\n"
	"	// just grabbing the block of text that represents the font\n"
	"	// and giving it to the font manager to use later\n"
	"\n"
	"	var localFontName = getId(lines[i]);\n"
	"	var localFontData = lines[i];\n"
	"	i++;\n"
	"\n"
	"	while (i < lines.length && lines[i] != \"\") {\n"
	"		localFontData += \"\\n\" + lines[i];\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	var localFontFilename = localFontName + fontManager.GetExtension();\n"
	"	fontManager.AddResource( localFontFilename, localFontData );\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseFlag(lines, i) {\n"
	"	var id = getId(lines[i]);\n"
	"	var valStr = lines[i].split(\" \")[2];\n"
	"	flags[id] = parseInt( valStr );\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function drawTile(tileId, x, y) {\n"
	"	bitsyDrawBegin(0);\n"
	"	bitsyDrawTile(tileId, x, y);\n"
	"	bitsyDrawEnd();\n"
	"}\n"
	"\n"
	"function drawSprite(tileId, x, y) {\n"
	"	drawTile(tileId, x, y);\n"
	"}\n"
	"\n"
	"function drawItem(tileId, x, y) {\n"
	"	drawTile(tileId, x, y);\n"
	"}\n"
	"\n"
	"// var debugLastRoomDrawn = \"0\";\n"
	"\n"
	"function clearRoom() {\n"
	"	var paletteId = \"default\";\n"
	"\n"
	"	if (room === undefined) {\n"
	"		// protect against invalid rooms\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	if (room.pal != null && palette[paletteId] != undefined) {\n"
	"		paletteId = room.pal;\n"
	"	}\n"
	"\n"
	"	bitsyDrawBegin(0);\n"
	"	bitsyClear(tileColorStartIndex);\n"
	"	bitsyDrawEnd();\n"
	"}\n"
	"\n"
	"function drawRoom(room, frameIndex) { // frameIndex is optional\n"
	"	// if (room.id != debugLastRoomDrawn) {\n"
	"	// 	debugLastRoomDrawn = room.id;\n"
	"	// 	bitsyLog(\"DRAW ROOM \" + debugLastRoomDrawn);\n"
	"	// }\n"
	"\n"
	"	if (room === undefined) {\n"
	"		// protect against invalid rooms\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	// clear the screen buffer\n"
	"	bitsyDrawBegin(0);\n"
	"	bitsyClear(tileColorStartIndex);\n"
	"	bitsyDrawEnd();\n"
	"\n"
	"	//draw tiles\n"
	"	for (i in room.tilemap) {\n"
	"		for (j in room.tilemap[i]) {\n"
	"			var id = room.tilemap[i][j];\n"
	"			var x = parseInt(j);\n"
	"			var y = parseInt(i);\n"
	"\n"
	"			if (id != \"0\") {\n"
	"				//bitsyLog(id);\n"
	"				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)\n"
	"					id = \"0\";\n"
	"					room.tilemap[i][j] = id;\n"
	"				}\n"
	"				else {\n"
	"					// bitsyLog(id);\n"
	"					drawTile(getTileFrame(tile[id], frameIndex), x, y);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	//draw items\n"
	"	for (var i = 0; i < room.items.length; i++) {\n"
	"		var itm = room.items[i];\n"
	"		drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);\n"
	"	}\n"
	"\n"
	"	//draw sprites\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (spr.room === room.id) {\n"
	"			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"// TODO : remove these get*Image methods\n"
	"function getTileFrame(t, frameIndex) {\n"
	"	return renderer.GetDrawingFrame(t, frameIndex);\n"
	"}\n"
	"\n"
	"function getSpriteFrame(s, frameIndex) {\n"
	"	return renderer.GetDrawingFrame(s, frameIndex);\n"
	"}\n"
	"\n"
	"function getItemFrame(itm, frameIndex) {\n"
	"	return renderer.GetDrawingFrame(itm, frameIndex);\n"
	"}\n"
	"\n"
	"function curPal() {\n"
	"	return getRoomPal(curRoom);\n"
	"}\n"
	"\n"
	"function getRoomPal(roomId) {\n"
	"	var defaultId = \"default\";\n"
	"\n"
	"	if (roomId == null) {\n"
	"		return defaultId;\n"
	"	}\n"
	"	else if (room[roomId].pal != null) {\n"
	"		//a specific palette was chosen\n"
	"		return room[roomId].pal;\n"
	"	}\n"
	"	else {\n"
	"		if (roomId in palette) {\n"
	"			//there is a palette matching the name of the room\n"
	"			return roomId;\n"
	"		}\n"
	"		else {\n"
	"			//use the default palette\n"
	"			return defaultId;\n"
	"		}\n"
	"	}\n"
	"	return defaultId;\n"
	"}\n"
	"\n"
	"var isDialogMode = false;\n"
	"var isNarrating = false;\n"
	"var isEnding = false;\n"
	"var dialogModule = new Dialog();\n"
	"var dialogRenderer = dialogModule.CreateRenderer();\n"
	"var dialogBuffer = dialogModule.CreateBuffer();\n"
	"var fontManager = new FontManager();\n"
	"\n"
	"// TODO : is this scriptResult thing being used anywhere???\n"
	"function onExitDialog(scriptResult, dialogCallback) {\n"
	"	bitsyLog(\"EXIT DIALOG!\");\n"
	"\n"
	"	isDialogMode = false;\n"
	"\n"
	"	if (isNarrating) {\n"
	"		isNarrating = false;\n"
	"	}\n"
	"\n"
	"	if (isDialogPreview) {\n"
	"		isDialogPreview = false;\n"
	"\n"
	"		if (onDialogPreviewEnd != null) {\n"
	"			onDialogPreviewEnd();\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (dialogCallback != undefined && dialogCallback != null) {\n"
	"		dialogCallback(scriptResult);\n"
	"	}\n"
	"}\n"
	"\n"
	"/*\n"
	"TODO\n"
	"- titles and endings should also take advantage of the script pre-compilation if possible??\n"
	"- could there be a namespace collision?\n"
	"- what about dialog NAMEs vs IDs?\n"
	"- what about a special script block separate from DLG?\n"
	"*/\n"
	"function startNarrating(dialogStr,end) {\n"
	"	bitsyLog(\"NARRATE \" + dialogStr);\n"
	"\n"
	"	if(end === undefined) {\n"
	"		end = false;\n"
	"	}\n"
	"\n"
	"	isNarrating = true;\n"
	"	isEnding = end;\n"
	"\n"
	"	startDialog(dialogStr);\n"
	"}\n"
	"\n"
	"function startEndingDialog(ending) {\n"
	"	isNarrating = true;\n"
	"	isEnding = true;\n"
	"\n"
	"	startDialog(\n"
	"		dialog[ending.id].src,\n"
	"		ending.id,\n"
	"		function() {\n"
	"			var isLocked = ending.property && ending.property.locked === true;\n"
	"			if (isLocked) {\n"
	"				isEnding = false;\n"
	"			}\n"
	"		},\n"
	"		ending);\n"
	"}\n"
	"\n"
	"function startItemDialog(itemId, dialogCallback) {\n"
	"	var dialogId = item[itemId].dlg;\n"
	"	// bitsyLog(\"START ITEM DIALOG \" + dialogId);\n"
	"	if (dialog[dialogId]) {\n"
	"		var dialogStr = dialog[dialogId].src;\n"
	"		startDialog(dialogStr, dialogId, dialogCallback);\n"
	"	}\n"
	"	else {\n"
	"		dialogCallback();\n"
	"	}\n"
	"}\n"
	"\n"
	"function startSpriteDialog(spriteId) {\n"
	"	var spr = sprite[spriteId];\n"
	"	var dialogId = spr.dlg;\n"
	"	// bitsyLog(\"START SPRITE DIALOG \" + dialogId);\n"
	"	if (dialog[dialogId]){\n"
	"		var dialogStr = dialog[dialogId].src;\n"
	"		startDialog(dialogStr,dialogId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {\n"
	"	// bitsyLog(\"START DIALOG \");\n"
	"	if (dialogStr.length <= 0) {\n"
	"		// bitsyLog(\"ON EXIT DIALOG -- startDialog 1\");\n"
	"		onExitDialog(null, dialogCallback);\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	isDialogMode = true;\n"
	"\n"
	"	dialogRenderer.Reset();\n"
	"	dialogRenderer.SetCentered(isNarrating /*centered*/);\n"
	"	dialogBuffer.Reset();\n"
	"	scriptInterpreter.SetDialogBuffer(dialogBuffer);\n"
	"\n"
	"	var onScriptEnd = function(scriptResult) {\n"
	"		dialogBuffer.OnDialogEnd(function() {\n"
	"			onExitDialog(scriptResult, dialogCallback);\n"
	"		});\n"
	"	};\n"
	"\n"
	"	if (scriptId === undefined) { // TODO : what's this for again?\n"
	"		scriptInterpreter.Interpret(dialogStr, onScriptEnd);\n"
	"	}\n"
	"	else {\n"
	"		if (!scriptInterpreter.HasScript(scriptId)) {\n"
	"			scriptInterpreter.Compile(scriptId, dialogStr);\n"
	"		}\n"
	"		// scriptInterpreter.DebugVisualizeScript(scriptId);\n"
	"		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);\n"
	"	}\n"
	"\n"
	"}\n"
	"\n"
	"var isDialogPreview = false;\n"
	"function startPreviewDialog(script, dialogCallback) {\n"
	"	isNarrating = true;\n"
	"\n"
	"	isDialogMode = true;\n"
	"\n"
	"	isDialogPreview = true;\n"
	"\n"
	"	dialogRenderer.Reset();\n"
	"	dialogRenderer.SetCentered(true);\n"
	"	dialogBuffer.Reset();\n"
	"	scriptInterpreter.SetDialogBuffer(dialogBuffer);\n"
	"\n"
	"	// TODO : do I really need a seperate callback for this debug mode??\n"
	"	onDialogPreviewEnd = dialogCallback;\n"
	"\n"
	"	var onScriptEndCallback = function(scriptResult) {\n"
	"		dialogBuffer.OnDialogEnd(function() {\n"
	"			onExitDialog(scriptResult, null);\n"
	"		});\n"
	"	};\n"
	"\n"
	"	scriptInterpreter.Eval(script, onScriptEndCallback);\n"
	"}\n"
	"\n"
	"/* NEW SCRIPT STUFF */\n"
	"var scriptModule = new Script();\n"
	"var scriptInterpreter = scriptModule.CreateInterpreter();\n"
	"var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?\n"
	"// scriptInterpreter.SetDialogBuffer( dialogBuffer );\n"
	"\n"
	"/* EVENTS */\n"
	"bitsyOnUpdate(update);\n"
	"bitsyOnQuit(stopGame);\n"
	"bitsyOnLoad(load_game);\n";

char* dialog_js =
	"function Dialog() {\n"
	"\n"
	"this.CreateRenderer = function() {\n"
	"	return new DialogRenderer();\n"
	"};\n"
	"\n"
	"this.CreateBuffer = function() {\n"
	"	return new DialogBuffer();\n"
	"};\n"
	"\n"
	"var DialogRenderer = function() {\n"
	"\n"
	"	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?\n"
	"	var textboxInfo = {\n"
	"		width : 104,\n"
	"		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow\n"
	"		top : 12,\n"
	"		left : 12,\n"
	"		bottom : 12, //for drawing it from the bottom\n"
	"		font_scale : 0.5, // we draw font at half-size compared to everything else\n"
	"		padding_vert : 2,\n"
	"		padding_horz : 4,\n"
	"		arrow_height : 5,\n"
	"	};\n"
	"\n"
	"	var font = null;\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;\n"
	"\n"
	"		// todo : clean up all the scale stuff\n"
	"		var textboxScaleW = textboxInfo.width / textboxInfo.font_scale;\n"
	"		var textboxScaleH = textboxInfo.height / textboxInfo.font_scale;\n"
	"		bitsySetTextboxSize(textboxScaleW, textboxScaleH);\n"
	"	}\n"
	"\n"
	"	function textScale() {\n"
	"		return scale * textboxInfo.font_scale;\n"
	"	}\n"
	"\n"
	"	function relativeFontWidth() {\n"
	"		return Math.ceil( font.getWidth() * textboxInfo.font_scale );\n"
	"	}\n"
	"\n"
	"	function relativeFontHeight() {\n"
	"		return Math.ceil( font.getHeight() * textboxInfo.font_scale );\n"
	"	}\n"
	"\n"
	"	this.ClearTextbox = function() {\n"
	"		bitsyDrawBegin(1);\n"
	"		bitsyClear(textBackgroundIndex);\n"
	"		bitsyDrawEnd();\n"
	"	};\n"
	"\n"
	"	var isCentered = false;\n"
	"	this.SetCentered = function(centered) {\n"
	"		isCentered = centered;\n"
	"	};\n"
	"\n"
	"	this.DrawTextbox = function() {\n"
	"		bitsyDrawBegin(0);\n"
	"\n"
	"		if (isCentered) {\n"
	"			// todo : will the height calculations always work?\n"
	"			bitsyDrawTextbox(textboxInfo.left, ((height / 2) - (textboxInfo.height / 2)));\n"
	"		}\n"
	"		else if (player().y < (mapsize / 2)) {\n"
	"			// bottom\n"
	"			bitsyDrawTextbox(textboxInfo.left, (height - textboxInfo.bottom - textboxInfo.height));\n"
	"		}\n"
	"		else {\n"
	"			// top\n"
	"			bitsyDrawTextbox(textboxInfo.left, textboxInfo.top);\n"
	"		}\n"
	"\n"
	"		bitsyDrawEnd();\n"
	"	};\n"
	"\n"
	"	var arrowdata = [\n"
	"		1,1,1,1,1,\n"
	"		0,1,1,1,0,\n"
	"		0,0,1,0,0\n"
	"	];\n"
	"\n"
	"	this.DrawNextArrow = function() {\n"
	"		// bitsyLog(\"draw arrow!\");\n"
	"		bitsyDrawBegin(1);\n"
	"\n"
	"		var top = (textboxInfo.height - 5) * text_scale;\n"
	"		var left = (textboxInfo.width - (5 + 4)) * text_scale;\n"
	"		if (textDirection === TextDirection.RightToLeft) { // RTL hack\n"
	"			left = 4 * text_scale;\n"
	"		}\n"
	"\n"
	"		for (var y = 0; y < 3; y++) {\n"
	"			for (var x = 0; x < 5; x++) {\n"
	"				var i = (y * 5) + x;\n"
	"				if (arrowdata[i] == 1) {\n"
	"					//scaling nonsense\n"
	"					for (var sy = 0; sy < text_scale; sy++) {\n"
	"						for (var sx = 0; sx < text_scale; sx++) {\n"
	"							bitsyDrawPixel(textArrowIndex, left + (x * text_scale) + sx, top + (y * text_scale) + sy);\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		bitsyDrawEnd();\n"
	"	};\n"
	"\n"
	"	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better\n"
	"	this.DrawChar = function(char, row, col, leftPos) {\n"
	"		bitsyDrawBegin(1);\n"
	"\n"
	"		char.offset = {\n"
	"			x: char.base_offset.x,\n"
	"			y: char.base_offset.y\n"
	"		}; // compute render offset *every* frame\n"
	"\n"
	"		char.SetPosition(row,col);\n"
	"		char.ApplyEffects(effectTime);\n"
	"\n"
	"		var charData = char.bitmap;\n"
	"\n"
	"		var top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);\n"
	"		var left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);\n"
	"\n"
	"		for (var y = 0; y < char.height; y++) {\n"
	"			for (var x = 0; x < char.width; x++) {\n"
	"				var i = (y * char.width) + x;\n"
	"				if (charData[i] == 1) {\n"
	"					// todo : other colors\n"
	"					bitsyDrawPixel(char.color, left + x, top + y);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		bitsyDrawEnd();\n"
	"\n"
	"		// call printHandler for character\n"
	"		char.OnPrint();\n"
	"	};\n"
	"\n"
	"	var effectTime = 0; // TODO this variable should live somewhere better\n"
	"	this.Draw = function(buffer, dt) {\n"
	"		effectTime += dt;\n"
	"\n"
	"		this.ClearTextbox();\n"
	"\n"
	"		buffer.ForEachActiveChar(this.DrawChar);\n"
	"\n"
	"		if (buffer.CanContinue()) {\n"
	"			this.DrawNextArrow();\n"
	"		}\n"
	"\n"
	"		this.DrawTextbox();\n"
	"\n"
	"		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {\n"
	"			onPageFinish();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var onPageFinish = null;\n"
	"	this.SetPageFinishHandler = function(handler) {\n"
	"		onPageFinish = handler;\n"
	"	};\n"
	"\n"
	"	this.Reset = function() {\n"
	"		effectTime = 0;\n"
	"		// TODO - anything else?\n"
	"	}\n"
	"\n"
	"	// this.CharsPerRow = function() {\n"
	"	// 	return textboxInfo.charsPerRow;\n"
	"	// }\n"
	"}\n"
	"\n"
	"\n"
	"var DialogBuffer = function() {\n"
	"	var buffer = [[[]]]; // holds dialog in an array buffer\n"
	"	var pageIndex = 0;\n"
	"	var rowIndex = 0;\n"
	"	var charIndex = 0;\n"
	"	var nextCharTimer = 0;\n"
	"	var nextCharMaxTime = 50; // in milliseconds\n"
	"	var isDialogReadyToContinue = false;\n"
	"	var activeTextEffects = [];\n"
	"	var font = null;\n"
	"	var arabicHandler = new ArabicHandler();\n"
	"	var onDialogEndCallbacks = [];\n"
	"\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"	}\n"
	"\n"
	"	this.CurPage = function() { return buffer[ pageIndex ]; };\n"
	"	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };\n"
	"	this.CurChar = function() { return this.CurRow()[ charIndex ]; };\n"
	"	this.CurPageCount = function() { return buffer.length; };\n"
	"	this.CurRowCount = function() { return this.CurPage().length; };\n"
	"	this.CurCharCount = function() { return this.CurRow().length; };\n"
	"\n"
	"	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page\n"
	"		var rowCount = rowIndex + 1;\n"
	"		for (var i = 0; i < rowCount; i++) {\n"
	"			var row = this.CurPage()[i];\n"
	"			var charCount = (i == rowIndex) ? charIndex+1 : row.length;\n"
	"			// bitsyLog(charCount);\n"
	"\n"
	"			var leftPos = 0;\n"
	"			if (textDirection === TextDirection.RightToLeft) {\n"
	"				leftPos = 24 * 8; // hack -- I think this is correct?\n"
	"			}\n"
	"\n"
	"			for(var j = 0; j < charCount; j++) {\n"
	"				var char = row[j];\n"
	"				if(char) {\n"
	"					if (textDirection === TextDirection.RightToLeft) {\n"
	"						leftPos -= char.spacing;\n"
	"					}\n"
	"					// bitsyLog(j + \" \" + leftPos);\n"
	"\n"
	"					// handler( char, i /*rowIndex*/, j /*colIndex*/ );\n"
	"					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)\n"
	"\n"
	"					if (textDirection === TextDirection.LeftToRight) {\n"
	"						leftPos += char.spacing;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.Reset = function() {\n"
	"		buffer = [[[]]];\n"
	"		pageIndex = 0;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"		isDialogReadyToContinue = false;\n"
	"\n"
	"		afterManualPagebreak = false;\n"
	"\n"
	"		activeTextEffects = [];\n"
	"\n"
	"		onDialogEndCallbacks = [];\n"
	"\n"
	"		isActive = false;\n"
	"	};\n"
	"\n"
	"	this.DoNextChar = function() {\n"
	"		nextCharTimer = 0; //reset timer\n"
	"\n"
	"		//time to update characters\n"
	"		if (charIndex + 1 < this.CurCharCount()) {\n"
	"			//add char to current row\n"
	"			charIndex++;\n"
	"		}\n"
	"		else if (rowIndex + 1 < this.CurRowCount()) {\n"
	"			//start next row\n"
	"			rowIndex++;\n"
	"			charIndex = 0;\n"
	"		}\n"
	"		else {\n"
	"			//the page is full!\n"
	"			isDialogReadyToContinue = true;\n"
	"			didPageFinishThisFrame = true;\n"
	"		}\n"
	"\n"
	"		if (this.CurChar() != null) {\n"
	"			if (this.CurChar().isPageBreak) {\n"
	"				// special case for page break marker character!\n"
	"				isDialogReadyToContinue = true;\n"
	"				didPageFinishThisFrame = true;\n"
	"			}\n"
	"			\n"
	"			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.Update = function(dt) {\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"		// this.Draw(dt); // TODO move into a renderer object\n"
	"		if (isDialogReadyToContinue) {\n"
	"			return; //waiting for dialog to be advanced by player\n"
	"		}\n"
	"\n"
	"		nextCharTimer += dt; //tick timer\n"
	"\n"
	"		if (nextCharTimer > nextCharMaxTime) {\n"
	"			this.DoNextChar();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.Skip = function() {\n"
	"		bitsyLog(\"SKIPPP\");\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"		// add new characters until you get to the end of the current line of dialog\n"
	"		while (rowIndex < this.CurRowCount()) {\n"
	"			this.DoNextChar();\n"
	"\n"
	"			if(isDialogReadyToContinue) {\n"
	"				//make sure to push the rowIndex past the end to break out of the loop\n"
	"				rowIndex++;\n"
	"				charIndex = 0;\n"
	"			}\n"
	"		}\n"
	"		rowIndex = this.CurRowCount()-1;\n"
	"		charIndex = this.CurCharCount()-1;\n"
	"	};\n"
	"\n"
	"	this.FlipPage = function() {\n"
	"		didFlipPageThisFrame = true;\n"
	"		isDialogReadyToContinue = false;\n"
	"		pageIndex++;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"	}\n"
	"\n"
	"	this.EndDialog = function() {\n"
	"		isActive = false; // no more text to show... this should be a sign to stop rendering dialog\n"
	"\n"
	"		for (var i = 0; i < onDialogEndCallbacks.length; i++) {\n"
	"			onDialogEndCallbacks[i]();\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var afterManualPagebreak = false; // is it bad to track this state like this?\n"
	"\n"
	"	this.Continue = function() {\n"
	"		bitsyLog(\"CONTINUE\");\n"
	"\n"
	"		// if we used a page break character to continue we need\n"
	"		// to run whatever is in the script afterwards! // TODO : make this comment better\n"
	"		if (this.CurChar().isPageBreak) {\n"
	"			// hacky: always treat a page break as the end of dialog\n"
	"			// if there's more dialog later we re-activate the dialog buffer\n"
	"			this.EndDialog();\n"
	"			afterManualPagebreak = true;\n"
	"			this.CurChar().OnContinue();\n"
	"			return false;\n"
	"		}\n"
	"		if (pageIndex + 1 < this.CurPageCount()) {\n"
	"			bitsyLog(\"FLIP PAGE!\");\n"
	"			//start next page\n"
	"			this.FlipPage();\n"
	"			return true; /* hasMoreDialog */\n"
	"		}\n"
	"		else {\n"
	"			bitsyLog(\"END DIALOG!\");\n"
	"			//end dialog mode\n"
	"			this.EndDialog();\n"
	"			return false; /* hasMoreDialog */\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var isActive = false;\n"
	"	this.IsActive = function() { return isActive; };\n"
	"\n"
	"	this.OnDialogEnd = function(callback) {\n"
	"		if (!isActive) {\n"
	"			callback();\n"
	"		}\n"
	"		else {\n"
	"			onDialogEndCallbacks.push(callback);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CanContinue = function() { return isDialogReadyToContinue; };\n"
	"\n"
	"	function DialogChar(effectList) {\n"
	"		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)\n"
	"\n"
	"		this.color = textColorIndex; // white\n"
	"		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)\n"
	"\n"
	"		this.col = 0;\n"
	"		this.row = 0;\n"
	"\n"
	"		this.SetPosition = function(row,col) {\n"
	"			// bitsyLog(\"SET POS\");\n"
	"			// bitsyLog(this);\n"
	"			this.row = row;\n"
	"			this.col = col;\n"
	"		}\n"
	"\n"
	"		this.ApplyEffects = function(time) {\n"
	"			// bitsyLog(\"APPLY EFFECTS! \" + time);\n"
	"			for(var i = 0; i < this.effectList.length; i++) {\n"
	"				var effectName = this.effectList[i];\n"
	"				// bitsyLog(\"FX \" + effectName);\n"
	"				TextEffects[ effectName ].DoEffect( this, time );\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var printHandler = null; // optional function to be called once on printing character\n"
	"		this.SetPrintHandler = function(handler) {\n"
	"			printHandler = handler;\n"
	"		}\n"
	"		this.OnPrint = function() {\n"
	"			if (printHandler != null) {\n"
	"				// bitsyLog(\"PRINT HANDLER ---- DIALOG BUFFER\");\n"
	"				printHandler();\n"
	"				printHandler = null; // only call handler once (hacky)\n"
	"			}\n"
	"		}\n"
	"\n"
	"		this.bitmap = [];\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.base_offset = { // hacky name\n"
	" 			x: 0,\n"
	"			y: 0\n"
	"		};\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	function DialogFontChar(font, char, effectList) {\n"
	"		Object.assign(this, new DialogChar(effectList));\n"
	"\n"
	"		var charData = font.getChar(char);\n"
	"		this.bitmap = charData.data;\n"
	"		this.width = charData.width;\n"
	"		this.height = charData.height;\n"
	"		this.base_offset.x = charData.offset.x;\n"
	"		this.base_offset.y = charData.offset.y;\n"
	"		this.spacing = charData.spacing;\n"
	"	}\n"
	"\n"
	"	function DialogDrawingChar(drawingId, effectList) {\n"
	"		Object.assign(this, new DialogChar(effectList));\n"
	"\n"
	"		// get the first frame of the drawing and flatten it\n"
	"		var drawingData = renderer.GetDrawingSource(drawingId)[0];\n"
	"		var drawingDataFlat = [];\n"
	"		for (var i = 0; i < drawingData.length; i++) {\n"
	"			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);\n"
	"		}\n"
	"\n"
	"		this.bitmap = drawingDataFlat;\n"
	"		this.width = 8;\n"
	"		this.height = 8;\n"
	"		this.spacing = 8;\n"
	"	}\n"
	"\n"
	"	function DialogScriptControlChar() {\n"
	"		Object.assign(this, new DialogChar([]));\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	// is a control character really the best way to handle page breaks?\n"
	"	function DialogPageBreakChar() {\n"
	"		Object.assign(this, new DialogChar([]));\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"\n"
	"		this.isPageBreak = true;\n"
	"\n"
	"		var continueHandler = null;\n"
	"\n"
	"		this.SetContinueHandler = function(handler) {\n"
	"			continueHandler = handler;\n"
	"		}\n"
	"\n"
	"		this.OnContinue = function() {\n"
	"			if (continueHandler) {\n"
	"				continueHandler();\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function AddWordToCharArray(charArray,word,effectList) {\n"
	"		for(var i = 0; i < word.length; i++) {\n"
	"			charArray.push( new DialogFontChar( font, word[i], effectList ) );\n"
	"		}\n"
	"		return charArray;\n"
	"	}\n"
	"\n"
	"	function GetCharArrayWidth(charArray) {\n"
	"		var width = 0;\n"
	"		for(var i = 0; i < charArray.length; i++) {\n"
	"			width += charArray[i].spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	function GetStringWidth(str) {\n"
	"		var width = 0;\n"
	"		for (var i = 0; i < str.length; i++) {\n"
	"			var charData = font.getChar(str[i]);\n"
	"			width += charData.spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	var pixelsPerRow = 192; // hard-coded fun times!!!\n"
	"\n"
	"	this.AddScriptReturn = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var controlChar = new DialogScriptControlChar();\n"
	"		controlChar.SetPrintHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(controlChar);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddDrawing = function(drawingId) {\n"
	"		// bitsyLog(\"DRAWING ID \" + drawingId);\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);\n"
	"\n"
	"		var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"		// TODO : clean up copy-pasted code here :/\n"
	"		if (afterManualPagebreak) {\n"
	"			this.FlipPage(); // hacky\n"
	"\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"\n"
	"			afterManualPagebreak = false;\n"
	"		}\n"
	"		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {\n"
	"			//stay on same row\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else if (curRowIndex == 0) {\n"
	"			//start next row\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex++;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else {\n"
	"			//start next page\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"\n"
	"		isActive = true; // this feels like a bad way to do this???\n"
	"	}\n"
	"\n"
	"	// TODO : convert this into something that takes DialogChar arrays\n"
	"	this.AddText = function(textStr) {\n"
	"		bitsyLog(\"ADD TEXT \" + textStr);\n"
	"\n"
	"		//process dialog so it's easier to display\n"
	"		var words = textStr.split(\" \");\n"
	"\n"
	"		// var curPageIndex = this.CurPageCount() - 1;\n"
	"		// var curRowIndex = this.CurRowCount() - 1;\n"
	"		// var curRowArr = this.CurRow();\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		for (var i = 0; i < words.length; i++) {\n"
	"			var word = words[i];\n"
	"			if (arabicHandler.ContainsArabicCharacters(word)) {\n"
	"				word = arabicHandler.ShapeArabicCharacters(word);\n"
	"			}\n"
	"\n"
	"			var wordWithPrecedingSpace = ((i == 0) ? \"\" : \" \") + word;\n"
	"			var wordLength = GetStringWidth(wordWithPrecedingSpace);\n"
	"\n"
	"			var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"			if (afterManualPagebreak) {\n"
	"				this.FlipPage();\n"
	"\n"
	"				// hacky copied bit for page breaks\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);\n"
	"\n"
	"				afterManualPagebreak = false;\n"
	"			}\n"
	"			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {\n"
	"				//stay on same row\n"
	"				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects);\n"
	"			}\n"
	"			else if (curRowIndex == 0) {\n"
	"				//start next row\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex++;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);\n"
	"			}\n"
	"			else {\n"
	"				//start next page\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//destroy any empty stuff\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		var lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length == 0) {\n"
	"			lastPage.splice(lastPage.length-1, 1);\n"
	"		}\n"
	"		if (lastPage.length == 0) {\n"
	"			buffer.splice(buffer.length-1, 1);\n"
	"		}\n"
	"\n"
	"		//finish up \n"
	"		lastPage = buffer[buffer.length-1];\n"
	"		lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length > 0) {\n"
	"			var lastChar = lastRow[lastRow.length-1];\n"
	"		}\n"
	"\n"
	"		// bitsyLog(buffer);\n"
	"\n"
	"		isActive = true;\n"
	"	};\n"
	"\n"
	"	this.AddLinebreak = function() {\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		if (lastPage.length <= 1) {\n"
	"			// bitsyLog(\"LINEBREAK - NEW ROW \");\n"
	"			// add new row\n"
	"			lastPage.push([]);\n"
	"		}\n"
	"		else {\n"
	"			// add new page\n"
	"			buffer.push([[]]);\n"
	"		}\n"
	"		// bitsyLog(buffer);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddPagebreak = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		// need to actually create a whole new page if following another pagebreak character\n"
	"		if (this.CurChar() && this.CurChar().isPageBreak) {\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"		}\n"
	"\n"
	"		var pagebreakChar = new DialogPageBreakChar();\n"
	"		pagebreakChar.SetContinueHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(pagebreakChar);\n"
	"\n"
	"		isActive = true;		\n"
	"	}\n"
	"\n"
	"	/* new text effects */\n"
	"	this.HasTextEffect = function(name) {\n"
	"		return activeTextEffects.indexOf( name ) > -1;\n"
	"	}\n"
	"	this.AddTextEffect = function(name) {\n"
	"		activeTextEffects.push( name );\n"
	"	}\n"
	"	this.RemoveTextEffect = function(name) {\n"
	"		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );\n"
	"	}\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var didPageFinishThisFrame = false;\n"
	"	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };\n"
	"\n"
	"	var didFlipPageThisFrame = false;\n"
	"	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };\n"
	"\n"
	"	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky\n"
	"};\n"
	"\n"
	"/* ARABIC */\n"
	"var ArabicHandler = function() {\n"
	"\n"
	"	var arabicCharStart = 0x0621;\n"
	"	var arabicCharEnd = 0x064E;\n"
	"\n"
	"	var CharacterForm = {\n"
	"		Isolated : 0,\n"
	"		Final : 1,\n"
	"		Initial : 2,\n"
	"		Middle : 3\n"
	"	};\n"
	"\n"
	"	// map glyphs to their character forms\n"
	"	var glyphForms = {\n"
	"		/*		 Isolated, Final, Initial, Middle Forms	*/\n"
	"		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ \n"
	"		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ \n"
	"		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ \n"
	"		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ \n"
	"		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ \n"
	"		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ \n"
	"		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ \n"
	"		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ \n"
	"		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ \n"
	"		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ \n"
	"		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ \n"
	"		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ \n"
	"		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ \n"
	"		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ \n"
	"		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ \n"
	"		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ \n"
	"		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ \n"
	"		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ \n"
	"		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ \n"
	"		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ \n"
	"		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ \n"
	"		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ \n"
	"		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ \n"
	"		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ \n"
	"		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ \n"
	"		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ \n"
	"		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ \n"
	"		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ \n"
	"		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ \n"
	"		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ \n"
	"		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ \n"
	"		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ \n"
	"		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ \n"
	"		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ \n"
	"		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ \n"
	"		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ \n"
	"		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ \n"
	"		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/\n"
	"		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/\n"
	"		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/\n"
	"		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */\n"
	"	};\n"
	"\n"
	"	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];\n"
	"\n"
	"	function IsArabicCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return (code >= arabicCharStart && code <= arabicCharEnd);\n"
	"	}\n"
	"\n"
	"	function ContainsArabicCharacters(word) {\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (IsArabicCharacter(word[i])) {\n"
	"				return true;\n"
	"			}\n"
	"		}\n"
	"		return false;\n"
	"	}\n"
	"\n"
	"	function IsDisconnectedCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return disconnectedCharacters.indexOf(code) != -1;\n"
	"	}\n"
	"\n"
	"	function ShapeArabicCharacters(word) {\n"
	"		var shapedWord = \"\";\n"
	"\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (!IsArabicCharacter(word[i])) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);\n"
	"\n"
	"			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);\n"
	"\n"
	"			var form;\n"
	"			if (!connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Isolated;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Final;\n"
	"			}\n"
	"			else if (!connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Initial;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Middle;\n"
	"			}\n"
	"\n"
	"			var code = word[i].charCodeAt(0);\n"
	"\n"
	"			// handle lam alef special case\n"
	"			if (code == 0x0644 && connectedToNextChar) {\n"
	"				var nextCode = word[i+1].charCodeAt(0);\n"
	"				var specialCode = null;\n"
	"				if (nextCode == 0x0622) {\n"
	"					// alef madd\n"
	"					specialCode = glyphForms[0x064b][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0623) {\n"
	"					// hamza above\n"
	"					specialCode = glyphForms[0x064c][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0625) {\n"
	"					// hamza below\n"
	"					specialCode = glyphForms[0x064d][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0627) {\n"
	"					// alef\n"
	"					specialCode = glyphForms[0x064e][form];\n"
	"				}\n"
	"\n"
	"				if (specialCode != null) {\n"
	"					shapedWord += String.fromCharCode(specialCode);\n"
	"					i++; // skip a step\n"
	"					continue;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			// hacky?\n"
	"			if (form === CharacterForm.Isolated) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var shapedCode = glyphForms[code][form];\n"
	"			shapedWord += String.fromCharCode(shapedCode);\n"
	"		}\n"
	"\n"
	"		return shapedWord;\n"
	"	}\n"
	"\n"
	"	this.ContainsArabicCharacters = ContainsArabicCharacters;\n"
	"	this.ShapeArabicCharacters = ShapeArabicCharacters;\n"
	"}\n"
	"\n"
	"/* NEW TEXT EFFECTS */\n"
	"var TextEffects = {};\n"
	"\n"
	"var RainbowEffect = function() {\n"
	"	this.DoEffect = function(char, time) {\n"
	"		char.color = rainbowColorStartIndex + Math.floor(((time / 100) - char.col * 0.5) % rainbowColorCount);\n"
	"	}\n"
	"};\n"
	"TextEffects[\"rbw\"] = new RainbowEffect();\n"
	"\n"
	"var ColorEffect = function(index) {\n"
	"	this.DoEffect = function(char) {\n"
	"		char.color = tileColorStartIndex + index;\n"
	"	}\n"
	"};\n"
	"TextEffects[\"clr1\"] = new ColorEffect(0);\n"
	"TextEffects[\"clr2\"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?\n"
	"TextEffects[\"clr3\"] = new ColorEffect(2);\n"
	"\n"
	"var WavyEffect = function() {\n"
	"	this.DoEffect = function(char,time) {\n"
	"		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;\n"
	"	}\n"
	"};\n"
	"TextEffects[\"wvy\"] = new WavyEffect();\n"
	"\n"
	"var ShakyEffect = function() {\n"
	"	function disturb(func, time, offset, mult1, mult2) {\n"
	"		return func((time * mult1) - (offset * mult2));\n"
	"	}\n"
	"\n"
	"	this.DoEffect = function(char,time) {\n"
	"		char.offset.y += 1.5\n"
	"						* disturb(Math.sin, time, char.col, 0.1, 0.5)\n"
	"						* disturb(Math.cos, time, char.col, 0.3, 0.2)\n"
	"						* disturb(Math.sin, time, char.row, 2.0, 1.0);\n"
	"		char.offset.x += 1.5\n"
	"						* disturb(Math.cos, time, char.row, 0.1, 1.0)\n"
	"						* disturb(Math.sin, time, char.col, 3.0, 0.7)\n"
	"						* disturb(Math.cos, time, char.col, 0.2, 0.3);\n"
	"	}\n"
	"};\n"
	"TextEffects[\"shk\"] = new ShakyEffect();\n"
	"\n"
	"var DebugHighlightEffect = function() {\n"
	"	this.DoEffect = function(char) {\n"
	"		char.color = tileColorStartIndex;\n"
	"	}\n"
	"}\n"
	"TextEffects[\"_debug_highlight\"] = new DebugHighlightEffect();\n"
	"\n"
	"} // Dialog()\n";

char* font_js =
	"/*\n"
	"TODO:\n"
	"- can I simplify this more now that I've removed the external resources stuff?\n"
	"*/\n"
	"\n"
	"function FontManager(packagedFontNames) {\n"
	"\n"
	"var self = this;\n"
	"\n"
	"var fontExtension = \".bitsyfont\";\n"
	"this.GetExtension = function() {\n"
	"	return fontExtension;\n"
	"}\n"
	"\n"
	"// place to store font data\n"
	"var fontResources = {};\n"
	"\n"
	"// load fonts from the editor\n"
	"if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0\n"
	"		&& Resources != undefined && Resources != null) {\n"
	"\n"
	"	for (var i = 0; i < packagedFontNames.length; i++) {\n"
	"		var filename = packagedFontNames[i];\n"
	"		fontResources[filename] = Resources[filename];\n"
	"	}\n"
	"}\n"
	"\n"
	"// manually add resource\n"
	"this.AddResource = function(filename, fontdata) {\n"
	"	fontResources[filename] = fontdata;\n"
	"}\n"
	"\n"
	"this.ContainsResource = function(filename) {\n"
	"	return fontResources[filename] != null;\n"
	"}\n"
	"\n"
	"function GetData(fontName) {\n"
	"	return fontResources[fontName + fontExtension];\n"
	"}\n"
	"this.GetData = GetData;\n"
	"\n"
	"function Create(fontData) {\n"
	"	return new Font(fontData);\n"
	"}\n"
	"this.Create = Create;\n"
	"\n"
	"this.Get = function(fontName) {\n"
	"	var fontData = self.GetData(fontName);\n"
	"	return self.Create(fontData);\n"
	"}\n"
	"\n"
	"function Font(fontData) {\n"
	"	var name = \"unknown\";\n"
	"	var width = 6; // default size so if you have NO font or an invalid font it displays boxes\n"
	"	var height = 8;\n"
	"	var chardata = {};\n"
	"\n"
	"	// create invalid char data at default size in case the font is missing\n"
	"	var invalidCharData = {};\n"
	"	updateInvalidCharData();\n"
	"\n"
	"	this.getName = function() {\n"
	"		return name;\n"
	"	}\n"
	"\n"
	"	this.getData = function() {\n"
	"		return chardata;\n"
	"	}\n"
	"\n"
	"	this.getWidth = function() {\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	this.getHeight = function() {\n"
	"		return height;\n"
	"	}\n"
	"\n"
	"	this.hasChar = function(char) {\n"
	"		var codepoint = char.charCodeAt(0);\n"
	"		return chardata[codepoint] != null;\n"
	"	}\n"
	"\n"
	"	this.getChar = function(char) {\n"
	"\n"
	"		var codepoint = char.charCodeAt(0);\n"
	"\n"
	"		if (chardata[codepoint] != null) {\n"
	"			return chardata[codepoint];\n"
	"		}\n"
	"		else {\n"
	"			return invalidCharData;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.allCharCodes = function() {\n"
	"		var codeList = [];\n"
	"		for (var code in chardata) {\n"
	"			codeList.push(code);\n"
	"		}\n"
	"		return codeList;\n"
	"	}\n"
	"\n"
	"	function createCharData() {\n"
	"		return { \n"
	"			width: width,\n"
	"			height: height,\n"
	"			offset: {\n"
	"				x: 0,\n"
	"				y: 0\n"
	"			},\n"
	"			spacing: width,\n"
	"			data: [],\n"
	"		};\n"
	"	}\n"
	"\n"
	"	function updateInvalidCharData() {\n"
	"		invalidCharData = createCharData();\n"
	"		for (var y = 0; y < height; y++) {\n"
	"			for (var x = 0; x < width; x++) {\n"
	"				if (x < width-1 && y < height-1) {\n"
	"					invalidCharData.data.push(1);\n"
	"				}\n"
	"				else {\n"
	"					invalidCharData.data.push(0);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function parseFont(fontData) {\n"
	"		if (fontData == null) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		var lines = fontData.split(\"\\n\");\n"
	"\n"
	"		var isReadingChar = false;\n"
	"		var isReadingCharProperties = false;\n"
	"		var curCharLineCount = 0;\n"
	"		var curCharCode = 0;\n"
	"\n"
	"		for (var i = 0; i < lines.length; i++) {\n"
	"			var line = lines[i];\n"
	"\n"
	"			if (line[0] === \"#\") {\n"
	"				continue; // skip comment lines\n"
	"			}\n"
	"\n"
	"			if (!isReadingChar) {\n"
	"				// READING NON CHARACTER DATA LINE\n"
	"				var args = line.split(\" \");\n"
	"				if (args[0] == \"FONT\") {\n"
	"					name = args[1];\n"
	"				}\n"
	"				else if (args[0] == \"SIZE\") {\n"
	"					width = parseInt(args[1]);\n"
	"					height = parseInt(args[2]);\n"
	"				}\n"
	"				else if (args[0] == \"CHAR\") {\n"
	"					isReadingChar = true;\n"
	"					isReadingCharProperties = true;\n"
	"\n"
	"					curCharLineCount = 0;\n"
	"					curCharCode = parseInt(args[1]);\n"
	"					chardata[curCharCode] = createCharData();\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				// CHAR PROPERTIES\n"
	"				if (isReadingCharProperties) {\n"
	"					var args = line.split(\" \");\n"
	"					if (args[0].indexOf(\"CHAR_\") == 0) { // Sub-properties start with \"CHAR_\"\n"
	"						if (args[0] == \"CHAR_SIZE\") {\n"
	"							// Custom character size - overrides the default character size for the font\n"
	"							chardata[curCharCode].width = parseInt(args[1]);\n"
	"							chardata[curCharCode].height = parseInt(args[2]);\n"
	"							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first\n"
	"						}\n"
	"						else if (args[0] == \"CHAR_OFFSET\") {\n"
	"							// Character offset - shift the origin of the character on the X or Y axis\n"
	"							chardata[curCharCode].offset.x = parseInt(args[1]);\n"
	"							chardata[curCharCode].offset.y = parseInt(args[2]);\n"
	"						}\n"
	"						else if (args[0] == \"CHAR_SPACING\") {\n"
	"							// Character spacing:\n"
	"							// specify total horizontal space taken up by the character\n"
	"							// lets chars take up more or less space on a line than its bitmap does\n"
	"							chardata[curCharCode].spacing = parseInt(args[1]);\n"
	"						}\n"
	"					}\n"
	"					else {\n"
	"						isReadingCharProperties = false;\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// CHAR DATA\n"
	"				if (!isReadingCharProperties) {\n"
	"					// READING CHARACTER DATA LINE\n"
	"					for (var j = 0; j < chardata[curCharCode].width; j++)\n"
	"					{\n"
	"						chardata[curCharCode].data.push( parseInt(line[j]) );\n"
	"					}\n"
	"\n"
	"					curCharLineCount++;\n"
	"					if (curCharLineCount >= height) {\n"
	"						isReadingChar = false;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// re-init invalid character box at the actual font size once it's loaded\n"
	"		updateInvalidCharData();\n"
	"	}\n"
	"\n"
	"	parseFont(fontData);\n"
	"}\n"
	"\n"
	"} // FontManager\n";

char* renderer_js =
	"function TileRenderer(tilesize) {\n"
	"// todo : do I need to pass in tilesize? or can I use the global value?\n"
	"\n"
	"bitsyLog(\"!!!!! NEW TILE RENDERER\");\n"
	"\n"
	"var drawingCache = {\n"
	"	source: {},\n"
	"	render: {},\n"
	"};\n"
	"\n"
	"// var debugRenderCount = 0;\n"
	"\n"
	"function createRenderCacheId(drawingId, colorIndex) {\n"
	"	return drawingId + \"_\" + colorIndex;\n"
	"}\n"
	"\n"
	"function renderDrawing(drawing) {\n"
	"	// debugRenderCount++;\n"
	"	// bitsyLog(\"RENDER COUNT \" + debugRenderCount);\n"
	"\n"
	"	var col = drawing.col;\n"
	"	var drwId = drawing.drw;\n"
	"	var drawingFrames = drawingCache.source[drwId];\n"
	"\n"
	"	// initialize render cache entry\n"
	"	var cacheId = createRenderCacheId(drwId, col);\n"
	"	if (drawingCache.render[cacheId] === undefined) {\n"
	"		// initialize array of frames for drawing\n"
	"		drawingCache.render[cacheId] = [];\n"
	"	}\n"
	"\n"
	"	for (var i = 0; i < drawingFrames.length; i++) {\n"
	"		var frameData = drawingFrames[i];\n"
	"		var frameTileId = renderTileFromDrawingData(frameData, col);\n"
	"		drawingCache.render[cacheId].push(frameTileId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function renderTileFromDrawingData(drawingData, col) {\n"
	"	var tileId = bitsyAddTile();\n"
	"\n"
	"	var backgroundColor = tileColorStartIndex + 0;\n"
	"	var foregroundColor = tileColorStartIndex + col;\n"
	"\n"
	"	bitsyDrawBegin(tileId);\n"
	"\n"
	"	for (var y = 0; y < tilesize; y++) {\n"
	"		for (var x = 0; x < tilesize; x++) {\n"
	"			var px = drawingData[y][x];\n"
	"\n"
	"			if (px === 1) {\n"
	"				bitsyDrawPixel(foregroundColor, x, y);\n"
	"			}\n"
	"			else {\n"
	"				bitsyDrawPixel(backgroundColor, x, y);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	bitsyDrawEnd();\n"
	"\n"
	"	return tileId;\n"
	"}\n"
	"\n"
	"// TODO : move into core\n"
	"function undefinedOrNull(x) {\n"
	"	return x === undefined || x === null;\n"
	"}\n"
	"\n"
	"function isDrawingRendered(drawing) {\n"
	"	var cacheId = createRenderCacheId(drawing.drw, drawing.col);\n"
	"	return drawingCache.render[cacheId] != undefined;\n"
	"}\n"
	"\n"
	"function getRenderedDrawingFrames(drawing) {\n"
	"	var cacheId = createRenderCacheId(drawing.drw, drawing.col);\n"
	"	return drawingCache.render[cacheId];\n"
	"}\n"
	"\n"
	"function getDrawingFrameTileId(drawing, frameOverride) {\n"
	"	var frameIndex = 0;\n"
	"\n"
	"	if (drawing != null && drawing.animation.isAnimated) {\n"
	"		if (frameOverride != undefined && frameOverride != null) {\n"
	"			frameIndex = frameOverride;\n"
	"		}\n"
	"		else {\n"
	"			frameIndex = drawing.animation.frameIndex;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	return getRenderedDrawingFrames(drawing)[frameIndex];\n"
	"}\n"
	"\n"
	"function getOrRenderDrawingFrame(drawing, frameOverride) {\n"
	"	// bitsyLog(\"frame render: \" + drawing.type + \" \" + drawing.id + \" f:\" + frameOverride);\n"
	"\n"
	"	if (!isDrawingRendered(drawing)) {\n"
	"		// bitsyLog(\"frame render: doesn't exist\");\n"
	"		renderDrawing(drawing);\n"
	"	}\n"
	"\n"
	"	return getDrawingFrameTileId(drawing, frameOverride);\n"
	"}\n"
	"\n"
	"/* PUBLIC INTERFACE */\n"
	"this.GetDrawingFrame = getOrRenderDrawingFrame;\n"
	"\n"
	"this.SetDrawingSource = function(drawingId, drawingData) {\n"
	"	drawingCache.source[drawingId] = drawingData;\n"
	"	// TODO : reset render cache for this image\n"
	"}\n"
	"\n"
	"this.GetDrawingSource = function(drawingId) {\n"
	"	return drawingCache.source[drawingId];\n"
	"}\n"
	"\n"
	"this.GetFrameCount = function(drawingId) {\n"
	"	return drawingCache.source[drawingId].length;\n"
	"}\n"
	"\n"
	"this.ClearCache = function() {\n"
	"	bitsyResetTiles();\n"
	"	drawingCache.render = {};\n"
	"}\n"
	"\n"
	"} // Renderer()\n";

char* script_js =
	"function Script() {\n"
	"\n"
	"this.CreateInterpreter = function() {\n"
	"	return new Interpreter();\n"
	"};\n"
	"\n"
	"this.CreateUtils = function() {\n"
	"	return new Utils();\n"
	"};\n"
	"\n"
	"var Interpreter = function() {\n"
	"	var env = new Environment();\n"
	"	var parser = new Parser( env );\n"
	"\n"
	"	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };\n"
	"\n"
	"	// TODO -- maybe this should return a string instead othe actual script??\n"
	"	this.Compile = function(scriptName, scriptStr) {\n"
	"		// bitsyLog(\"COMPILE\");\n"
	"		var script = parser.Parse(scriptStr, scriptName);\n"
	"		env.SetScript(scriptName, script);\n"
	"	}\n"
	"	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script\n"
	"		var localEnv = new LocalEnvironment(env);\n"
	"\n"
	"		if (objectContext) {\n"
	"			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?\n"
	"		}\n"
	"\n"
	"		var script = env.GetScript(scriptName);\n"
	"\n"
	"		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );\n"
	"	}\n"
	"	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately\n"
	"		// bitsyLog(\"INTERPRET\");\n"
	"		var localEnv = new LocalEnvironment(env);\n"
	"\n"
	"		if (objectContext) {\n"
	"			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?\n"
	"		}\n"
	"\n"
	"		var script = parser.Parse(scriptStr, \"anonymous\");\n"
	"		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );\n"
	"	}\n"
	"	this.HasScript = function(name) { return env.HasScript(name); };\n"
	"\n"
	"	this.ResetEnvironment = function() {\n"
	"		env = new Environment();\n"
	"		parser = new Parser( env );\n"
	"	}\n"
	"\n"
	"	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it\n"
	"		return parser.Parse(scriptStr, rootId);\n"
	"	}\n"
	"\n"
	"	// TODO : add back in if needed later...\n"
	"	// this.CompatibilityParse = function(scriptStr, compatibilityFlags) {\n"
	"	// 	env.compatibilityFlags = compatibilityFlags;\n"
	"\n"
	"	// 	var result = parser.Parse(scriptStr);\n"
	"\n"
	"	// 	delete env.compatibilityFlags;\n"
	"\n"
	"	// 	return result;\n"
	"	// }\n"
	"\n"
	"	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally\n"
	"		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?\n"
	"		scriptTree.Eval(\n"
	"			localEnv,\n"
	"			function(result) {\n"
	"				OnScriptReturn(result, exitHandler);\n"
	"			});\n"
	"	}\n"
	"\n"
	"	function OnScriptReturn(result, exitHandler) {\n"
	"		if (exitHandler != null) {\n"
	"			exitHandler(result);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CreateExpression = function(expStr) {\n"
	"		return parser.CreateExpression(expStr);\n"
	"	}\n"
	"\n"
	"	this.SetVariable = function(name,value,useHandler) {\n"
	"		env.SetVariable(name,value,useHandler);\n"
	"	}\n"
	"\n"
	"	this.DeleteVariable = function(name,useHandler) {\n"
	"		env.DeleteVariable(name,useHandler);\n"
	"	}\n"
	"	this.HasVariable = function(name) {\n"
	"		return env.HasVariable(name);\n"
	"	}\n"
	"\n"
	"	this.SetOnVariableChangeHandler = function(onVariableChange) {\n"
	"		env.SetOnVariableChangeHandler(onVariableChange);\n"
	"	}\n"
	"	this.GetVariableNames = function() {\n"
	"		return env.GetVariableNames();\n"
	"	}\n"
	"	this.GetVariable = function(name) {\n"
	"		return env.GetVariable(name);\n"
	"	}\n"
	"\n"
	"	function DebugVisualizeScriptTree(scriptTree) {\n"
	"		var printVisitor = {\n"
	"			Visit : function(node,depth) {\n"
	"				bitsyLog(\"-\".repeat(depth) + \"- \" + node.ToString());\n"
	"			},\n"
	"		};\n"
	"\n"
	"		scriptTree.VisitAll( printVisitor );\n"
	"	}\n"
	"\n"
	"	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;\n"
	"\n"
	"	this.DebugVisualizeScript = function(scriptName) {\n"
	"		DebugVisualizeScriptTree(env.GetScript(scriptName));\n"
	"	}\n"
	"}\n"
	"\n"
	"\n"
	"var Utils = function() {\n"
	"	// for editor ui\n"
	"	this.CreateDialogBlock = function(children,doIndentFirstLine) {\n"
	"		if (doIndentFirstLine === undefined) {\n"
	"			doIndentFirstLine = true;\n"
	"		}\n"
	"\n"
	"		var block = new DialogBlockNode(doIndentFirstLine);\n"
	"\n"
	"		for (var i = 0; i < children.length; i++) {\n"
	"			block.AddChild(children[i]);\n"
	"		}\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateOptionBlock = function() {\n"
	"		var block = new DialogBlockNode(false);\n"
	"		block.AddChild(new FuncNode(\"print\", [new LiteralNode(\" \")]));\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateItemConditionPair = function() {\n"
	"		var itemFunc = this.CreateFunctionBlock(\"item\", [\"0\"]);\n"
	"		var condition = new ExpNode(\"==\", itemFunc, new LiteralNode(1));\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"print\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateVariableConditionPair = function() {\n"
	"		var varNode = this.CreateVariableNode(\"a\");\n"
	"		var condition = new ExpNode(\"==\", varNode, new LiteralNode(1));\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"print\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateDefaultConditionPair = function() {\n"
	"		var condition = this.CreateElseNode();\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"print\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateEmptyPrintFunc = function() {\n"
	"		return new FuncNode(\"print\", [new LiteralNode(\"...\")]);\n"
	"	}\n"
	"\n"
	"	this.CreateFunctionBlock = function(name, initParamValues) {\n"
	"		var parameters = [];\n"
	"		for (var i = 0; i < initParamValues.length; i++) {\n"
	"			parameters.push(new LiteralNode(initParamValues[i]));\n"
	"		}\n"
	"\n"
	"		var node = new FuncNode(name, parameters);\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild(node);\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	// TODO : rename ParseStringToLiteralNode?\n"
	"	this.CreateLiteralNode = function(str) {\n"
	"		if (str === \"true\") {\n"
	"			return new LiteralNode(true);\n"
	"		}\n"
	"		else if (str === \"false\") {\n"
	"			return new LiteralNode(false);\n"
	"		}\n"
	"		else if (!isNaN(parseFloat(str))) {\n"
	"			return new LiteralNode(parseFloat(str));\n"
	"		}\n"
	"		else {\n"
	"			return new LiteralNode(str);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CreateVariableNode = function(variableName) {\n"
	"		return new VarNode(variableName);\n"
	"	}\n"
	"\n"
	"	this.CreatePropertyNode = function(propertyName, literalValue) {\n"
	"		var varNode = new VarNode(propertyName);\n"
	"		var valNode = new LiteralNode(literalValue);\n"
	"		var node = new FuncNode(\"property\", [varNode, valNode]);\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild(node);\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateElseNode = function() {\n"
	"		return new ElseNode();\n"
	"	}\n"
	"\n"
	"	this.CreateStringLiteralNode = function(str) {\n"
	"		return new LiteralNode(str);\n"
	"	}\n"
	"\n"
	"	// TODO : need to split up code & dialog blocks :|\n"
	"	this.CreateCodeBlock = function() {\n"
	"		return new CodeBlockNode();\n"
	"	}\n"
	"\n"
	"	this.ChangeSequenceType = function(oldSequence, type) {\n"
	"		if(type === \"sequence\") {\n"
	"			return new SequenceNode(oldSequence.children);\n"
	"		}\n"
	"		else if(type === \"cycle\") {\n"
	"			return new CycleNode(oldSequence.children);\n"
	"		}\n"
	"		else if(type === \"shuffle\") {\n"
	"			return new ShuffleNode(oldSequence.children);\n"
	"		}\n"
	"		return oldSequence;\n"
	"	}\n"
	"\n"
	"	this.CreateSequenceBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new SequenceNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateCycleBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new CycleNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateShuffleBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new ShuffleNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateIfBlock = function() {\n"
	"		var leftNode = new CodeBlockNode();\n"
	"		leftNode.AddChild( new FuncNode(\"item\", [new LiteralNode(\"0\")] ) );\n"
	"		var rightNode = new LiteralNode( 1 );\n"
	"		var condition1 = new ExpNode(\"==\", leftNode, rightNode );\n"
	"\n"
	"		var condition2 = new ElseNode();\n"
	"\n"
	"		var result1 = new DialogBlockNode();\n"
	"		result1.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var result2 = new DialogBlockNode();\n"
	"		result2.AddChild(new FuncNode(\"print\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( ifNode );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.ReadDialogScript = function(lines, i) {\n"
	"		var scriptStr = \"\";\n"
	"		if (lines[i] === Sym.DialogOpen) {\n"
	"			scriptStr += lines[i] + \"\\n\";\n"
	"			i++;\n"
	"			while(lines[i] != Sym.DialogClose) {\n"
	"				scriptStr += lines[i] + \"\\n\";\n"
	"				i++;\n"
	"			}\n"
	"			scriptStr += lines[i];\n"
	"			i++;\n"
	"		}\n"
	"		else {\n"
	"			scriptStr += lines[i];\n"
	"			i++;\n"
	"		}\n"
	"		return { script:scriptStr, index:i };\n"
	"	}\n"
	"\n"
	"	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript\n"
	"\n"
	"	this.EnsureDialogBlockFormat = function(dialogStr) {\n"
	"		// TODO -- what if it's already enclosed in dialog symbols??\n"
	"		if(dialogStr.indexOf('\\n') > -1) {\n"
	"			dialogStr = Sym.DialogOpen + \"\\n\" + dialogStr + \"\\n\" + Sym.DialogClose;\n"
	"		}\n"
	"		return dialogStr;\n"
	"	}\n"
	"\n"
	"	this.RemoveDialogBlockFormat = function(source) {\n"
	"		var sourceLines = source.split(\"\\n\");\n"
	"		var dialogStr = \"\";\n"
	"		if(sourceLines[0] === Sym.DialogOpen) {\n"
	"			// multi line\n"
	"			var i = 1;\n"
	"			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {\n"
	"				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\\n' : '');\n"
	"				i++;\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			// single line\n"
	"			dialogStr = source;\n"
	"		}\n"
	"		return dialogStr;\n"
	"	}\n"
	"\n"
	"	this.SerializeDialogNodeList = function(nodeList) {\n"
	"		var tempBlock = new DialogBlockNode(false);\n"
	"		 // set children directly to avoid breaking the parenting chain for this temp operation\n"
	"		tempBlock.children = nodeList;\n"
	"		return tempBlock.Serialize();\n"
	"	}\n"
	"\n"
	"	this.GetOperatorList = function() {\n"
	"		return [Sym.Set].concat(Sym.Operators);\n"
	"	}\n"
	"\n"
	"	this.IsInlineCode = function(node) {\n"
	"		return isInlineCode(node);\n"
	"	}\n"
	"}\n"
	"\n"
	"\n"
	"/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?\n"
	"function deprecatedFunc(environment,parameters,onReturn) {\n"
	"	bitsyLog(\"BITSY SCRIPT WARNING: Tried to use deprecated function\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function printFunc(environment, parameters, onReturn) {\n"
	"	if (parameters[0] != undefined && parameters[0] != null) {\n"
	"		var textStr = \"\" + parameters[0];\n"
	"		environment.GetDialogBuffer().AddText(textStr);\n"
	"		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"	}\n"
	"	else {\n"
	"		onReturn(null);\n"
	"	}\n"
	"}\n"
	"\n"
	"function linebreakFunc(environment, parameters, onReturn) {\n"
	"	// bitsyLog(\"LINEBREAK FUNC\");\n"
	"	environment.GetDialogBuffer().AddLinebreak();\n"
	"	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function pagebreakFunc(environment, parameters, onReturn) {\n"
	"	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function printDrawingFunc(environment, parameters, onReturn) {\n"
	"	var drawingId = parameters[0];\n"
	"	environment.GetDialogBuffer().AddDrawing(drawingId);\n"
	"	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function printSpriteFunc(environment,parameters,onReturn) {\n"
	"	var spriteId = parameters[0];\n"
	"	if(names.sprite[spriteId] != undefined) spriteId = names.sprite[spriteId]; // id is actually a name\n"
	"	var drawingId = sprite[spriteId].drw;\n"
	"	printDrawingFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function printTileFunc(environment,parameters,onReturn) {\n"
	"	var tileId = parameters[0];\n"
	"	if(names.tile[tileId] != undefined) tileId = names.tile[tileId]; // id is actually a name\n"
	"	var drawingId = tile[tileId].drw;\n"
	"	printDrawingFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function printItemFunc(environment,parameters,onReturn) {\n"
	"	var itemId = parameters[0];\n"
	"	if(names.item[itemId] != undefined) itemId = names.item[itemId]; // id is actually a name\n"
	"	var drawingId = item[itemId].drw;\n"
	"	printDrawingFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function printFontFunc(environment, parameters, onReturn) {\n"
	"	var allCharacters = \"\";\n"
	"	var font = fontManager.Get(fontName);\n"
	"	var codeList = font.allCharCodes();\n"
	"	for (var i = 0; i < codeList.length; i++) {\n"
	"		allCharacters += String.fromCharCode(codeList[i]) + \" \";\n"
	"	}\n"
	"	printFunc(environment, [allCharacters], onReturn);\n"
	"}\n"
	"\n"
	"function itemFunc(environment,parameters,onReturn) {\n"
	"	var itemId = parameters[0];\n"
	"\n"
	"	if (names.item[itemId] != undefined) {\n"
	"		// id is actually a name\n"
	"		itemId = names.item[itemId];\n"
	"	}\n"
	"\n"
	"	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;\n"
	"\n"
	"	if (parameters.length > 1) {\n"
	"		// TODO : is it a good idea to force inventory to be >= 0?\n"
	"		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));\n"
	"		curItemCount = player().inventory[itemId];\n"
	"\n"
	"		if (onInventoryChanged != null) {\n"
	"			onInventoryChanged(itemId);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	onReturn(curItemCount);\n"
	"}\n"
	"\n"
	"function addOrRemoveTextEffect(environment,name) {\n"
	"	if( environment.GetDialogBuffer().HasTextEffect(name) )\n"
	"		environment.GetDialogBuffer().RemoveTextEffect(name);\n"
	"	else\n"
	"		environment.GetDialogBuffer().AddTextEffect(name);\n"
	"}\n"
	"\n"
	"function rainbowFunc(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"rbw\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"// TODO : should the colors use a parameter instead of special names?\n"
	"function color1Func(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"clr1\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function color2Func(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"clr2\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function color3Func(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"clr3\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function wavyFunc(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"wvy\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function shakyFunc(environment,parameters,onReturn) {\n"
	"	addOrRemoveTextEffect(environment,\"shk\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function propertyFunc(environment, parameters, onReturn) {\n"
	"	var outValue = null;\n"
	"\n"
	"	if (parameters.length > 0 && parameters[0]) {\n"
	"		var propertyName = parameters[0];\n"
	"\n"
	"		if (environment.HasProperty(propertyName)) {\n"
	"			// TODO : in a future update I can handle the case of initializing a new property\n"
	"			// after which we can move this block outside the HasProperty check\n"
	"			if (parameters.length > 1) {\n"
	"				var inValue = parameters[1];\n"
	"				environment.SetProperty(propertyName, inValue);\n"
	"			}\n"
	"\n"
	"			outValue = environment.GetProperty(propertyName);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	bitsyLog(\"PROPERTY! \" + propertyName + \" \" + outValue);\n"
	"\n"
	"	onReturn(outValue);\n"
	"}\n"
	"\n"
	"function endFunc(environment,parameters,onReturn) {\n"
	"	isEnding = true;\n"
	"	isNarrating = true;\n"
	"	dialogRenderer.SetCentered(true);\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function exitFunc(environment,parameters,onReturn) {\n"
	"	var destRoom = parameters[0];\n"
	"\n"
	"	if (names.room[destRoom] != undefined) {\n"
	"		// it's a name, not an id! (note: these could cause trouble if people names things weird)\n"
	"		destRoom = names.room[destRoom];\n"
	"	}\n"
	"\n"
	"	var destX = parseInt(parameters[1]);\n"
	"	var destY = parseInt(parameters[2]);\n"
	"\n"
	"	if (parameters.length >= 4) {\n"
	"		var transitionEffect = parameters[3];\n"
	"\n"
	"		transition.BeginTransition(\n"
	"			player().room,\n"
	"			player().x,\n"
	"			player().y,\n"
	"			destRoom,\n"
	"			destX,\n"
	"			destY,\n"
	"			transitionEffect);\n"
	"		transition.UpdateTransition(0);\n"
	"	}\n"
	"\n"
	"	player().room = destRoom;\n"
	"	player().x = destX;\n"
	"	player().y = destY;\n"
	"	curRoom = destRoom;\n"
	"	initRoom(curRoom);\n"
	"\n"
	"	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!\n"
	"	if (transition.IsTransitionActive()) {\n"
	"		transition.OnTransitionComplete(function() { onReturn(null); });\n"
	"	}\n"
	"	else {\n"
	"		onReturn(null);\n"
	"	}\n"
	"}\n"
	"\n"
	"/* BUILT-IN OPERATORS */\n"
	"function setExp(environment,left,right,onReturn) {\n"
	"	// bitsyLog(\"SET \" + left.name);\n"
	"\n"
	"	if(left.type != \"variable\") {\n"
	"		// not a variable! return null and hope for the best D:\n"
	"		onReturn( null );\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	right.Eval(environment,function(rVal) {\n"
	"		environment.SetVariable( left.name, rVal );\n"
	"		// bitsyLog(\"VAL \" + environment.GetVariable( left.name ) );\n"
	"		left.Eval(environment,function(lVal) {\n"
	"			onReturn( lVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function equalExp(environment,left,right,onReturn) {\n"
	"	// bitsyLog(\"EVAL EQUAL\");\n"
	"	// bitsyLog(left);\n"
	"	// bitsyLog(right);\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal === rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function greaterExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal > rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function lessExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal < rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function greaterEqExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal >= rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function lessEqExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal <= rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function multExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal * rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function divExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal / rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function addExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal + rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function subExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal - rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"\n"
	"/* ENVIRONMENT */\n"
	"var Environment = function() {\n"
	"	var dialogBuffer = null;\n"
	"	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };\n"
	"	this.GetDialogBuffer = function() { return dialogBuffer; };\n"
	"\n"
	"	var functionMap = {};\n"
	"	functionMap[\"print\"] = printFunc;\n"
	"	functionMap[\"say\"] = printFunc;\n"
	"	functionMap[\"br\"] = linebreakFunc;\n"
	"	functionMap[\"item\"] = itemFunc;\n"
	"	functionMap[\"rbw\"] = rainbowFunc;\n"
	"	functionMap[\"clr1\"] = color1Func;\n"
	"	functionMap[\"clr2\"] = color2Func;\n"
	"	functionMap[\"clr3\"] = color3Func;\n"
	"	functionMap[\"wvy\"] = wavyFunc;\n"
	"	functionMap[\"shk\"] = shakyFunc;\n"
	"	functionMap[\"printSprite\"] = printSpriteFunc;\n"
	"	functionMap[\"printTile\"] = printTileFunc;\n"
	"	functionMap[\"printItem\"] = printItemFunc;\n"
	"	functionMap[\"debugOnlyPrintFont\"] = printFontFunc; // DEBUG ONLY\n"
	"	functionMap[\"end\"] = endFunc;\n"
	"	functionMap[\"exit\"] = exitFunc;\n"
	"	functionMap[\"pg\"] = pagebreakFunc;\n"
	"	functionMap[\"property\"] = propertyFunc;\n"
	"\n"
	"	this.HasFunction = function(name) { return functionMap[name] != undefined; };\n"
	"	this.EvalFunction = function(name,parameters,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		functionMap[name](env, parameters, onReturn);\n"
	"	}\n"
	"\n"
	"	var variableMap = {};\n"
	"\n"
	"	this.HasVariable = function(name) { return variableMap[name] != undefined; };\n"
	"	this.GetVariable = function(name) { return variableMap[name]; };\n"
	"	this.SetVariable = function(name,value,useHandler) {\n"
	"		// bitsyLog(\"SET VARIABLE \" + name + \" = \" + value);\n"
	"		if(useHandler === undefined) useHandler = true;\n"
	"		variableMap[name] = value;\n"
	"		if(onVariableChangeHandler != null && useHandler){\n"
	"			onVariableChangeHandler(name);\n"
	"		}\n"
	"	};\n"
	"	this.DeleteVariable = function(name,useHandler) {\n"
	"		if(useHandler === undefined) useHandler = true;\n"
	"		if(variableMap[name] != undefined) {\n"
	"			variableMap.delete(name);\n"
	"			if(onVariableChangeHandler != null && useHandler) {\n"
	"				onVariableChangeHandler(name);\n"
	"			}\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var operatorMap = {};\n"
	"	operatorMap[\"=\"] = setExp;\n"
	"	operatorMap[\"==\"] = equalExp;\n"
	"	operatorMap[\">\"] = greaterExp;\n"
	"	operatorMap[\"<\"] = lessExp;\n"
	"	operatorMap[\">=\"] = greaterEqExp;\n"
	"	operatorMap[\"<=\"] = lessEqExp;\n"
	"	operatorMap[\"*\"] = multExp;\n"
	"	operatorMap[\"/\"] = divExp;\n"
	"	operatorMap[\"+\"] = addExp;\n"
	"	operatorMap[\"-\"] = subExp;\n"
	"\n"
	"	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };\n"
	"	this.EvalOperator = function(sym,left,right,onReturn) {\n"
	"		operatorMap[ sym ]( this, left, right, onReturn );\n"
	"	}\n"
	"\n"
	"	var scriptMap = {};\n"
	"	this.HasScript = function(name) { return scriptMap[name] != undefined; };\n"
	"	this.GetScript = function(name) { return scriptMap[name]; };\n"
	"	this.SetScript = function(name,script) { scriptMap[name] = script; };\n"
	"\n"
	"	var onVariableChangeHandler = null;\n"
	"	this.SetOnVariableChangeHandler = function(onVariableChange) {\n"
	"		onVariableChangeHandler = onVariableChange;\n"
	"	}\n"
	"	this.GetVariableNames = function() {\n"
	"		var variableNames = [];\n"
	"\n"
	"		for (var key in variableMap) {\n"
	"			variableNames.push(key);\n"
	"		}\n"
	"\n"
	"		return variableNames;\n"
	"	}\n"
	"}\n"
	"\n"
	"// Local environment for a single run of a script: knows local context\n"
	"var LocalEnvironment = function(parentEnvironment) {\n"
	"	// this.SetDialogBuffer // not allowed in local environment?\n"
	"	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };\n"
	"\n"
	"	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };\n"
	"	this.EvalFunction = function(name,parameters,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		parentEnvironment.EvalFunction(name,parameters,onReturn,env);\n"
	"	}\n"
	"\n"
	"	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };\n"
	"	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };\n"
	"	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };\n"
	"	// this.DeleteVariable // not needed in local environment?\n"
	"\n"
	"	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };\n"
	"	this.EvalOperator = function(sym,left,right,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);\n"
	"	};\n"
	"\n"
	"	// TODO : I don't *think* any of this is required by the local environment\n"
	"	// this.HasScript\n"
	"	// this.GetScript\n"
	"	// this.SetScript\n"
	"\n"
	"	// TODO : pretty sure these debug methods aren't required by the local environment either\n"
	"	// this.SetOnVariableChangeHandler\n"
	"	// this.GetVariableNames\n"
	"\n"
	"	/* Here's where specific local context data goes:\n"
	"	 * this includes access to the object running the script\n"
	"	 * and any properties it may have (so far only \"locked\")\n"
	"	 */\n"
	"\n"
	"	// The local environment knows what object called it -- currently only used to access properties\n"
	"	var curObject = null;\n"
	"	this.HasObject = function() { return curObject != undefined && curObject != null; }\n"
	"	this.SetObject = function(object) { curObject = object; }\n"
	"	this.GetObject = function() { return curObject; }\n"
	"\n"
	"	// accessors for properties of the object that's running the script\n"
	"	this.HasProperty = function(name) {\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			return true;\n"
	"		}\n"
	"		else {\n"
	"			return false;\n"
	"		}\n"
	"	};\n"
	"	this.GetProperty = function(name) {\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			return curObject.property[name]; // TODO : should these be getters and setters instead?\n"
	"		}\n"
	"		else {\n"
	"			return null;\n"
	"		}\n"
	"	};\n"
	"	this.SetProperty = function(name, value) {\n"
	"		// NOTE : for now, we need to gaurd against creating new properties\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			curObject.property[name] = value;\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"function leadingWhitespace(depth) {\n"
	"	var str = \"\";\n"
	"	for(var i = 0; i < depth; i++) {\n"
	"		str += \"  \"; // two spaces per indent\n"
	"	}\n"
	"	// bitsyLog(\"WHITESPACE \" + depth + \" ::\" + str + \"::\");\n"
	"	return str;\n"
	"}\n"
	"\n"
	"/* NODES */\n"
	"var TreeRelationship = function() {\n"
	"	this.parent = null;\n"
	"	this.children = [];\n"
	"\n"
	"	this.AddChild = function(node) {\n"
	"		this.children.push(node);\n"
	"		node.parent = this;\n"
	"	};\n"
	"\n"
	"	this.AddChildren = function(nodeList) {\n"
	"		for (var i = 0; i < nodeList.length; i++) {\n"
	"			this.AddChild(nodeList[i]);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.SetChildren = function(nodeList) {\n"
	"		this.children = [];\n"
	"		this.AddChildren(nodeList);\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll( visitor, depth + 1 );\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.rootId = null; // for debugging\n"
	"	this.GetId = function() {\n"
	"		// bitsyLog(this);\n"
	"		if (this.rootId != null) {\n"
	"			return this.rootId;\n"
	"		}\n"
	"		else if (this.parent != null) {\n"
	"			var parentId = this.parent.GetId();\n"
	"			if (parentId != null) {\n"
	"				return parentId + \"_\" + this.parent.children.indexOf(this);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			return null;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"var DialogBlockNode = function(doIndentFirstLine) {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	// Object.assign( this, new Runnable() );\n"
	"	this.type = \"dialog_block\";\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsyLog(\"EVAL BLOCK \" + this.children.length);\n"
	"\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var lastVal = null;\n"
	"		var i = 0;\n"
	"\n"
	"		function evalChildren(children, done) {\n"
	"			if (i < children.length) {\n"
	"				// bitsyLog(\">> CHILD \" + i);\n"
	"				children[i].Eval(environment, function(val) {\n"
	"					// bitsyLog(\"<< CHILD \" + i);\n"
	"					lastVal = val;\n"
	"					i++;\n"
	"					evalChildren(children,done);\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var self = this;\n"
	"		evalChildren(this.children, function() {\n"
	"			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"				events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"			}\n"
	"\n"
	"			onReturn(lastVal);\n"
	"		});\n"
	"	}\n"
	"\n"
	"	if (doIndentFirstLine === undefined) {\n"
	"		doIndentFirstLine = true; // This is just for serialization\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		if (depth === undefined) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		var str = \"\";\n"
	"		var lastNode = null;\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"\n"
	"			var curNode = this.children[i];\n"
	"\n"
	"			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);\n"
	"			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === \"function\" && lastNode.name === \"br\");\n"
	"\n"
	"			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {\n"
	"				str += leadingWhitespace(depth);\n"
	"			}\n"
	"\n"
	"			str += curNode.Serialize(depth);\n"
	"\n"
	"			lastNode = curNode;\n"
	"		}\n"
	"\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var CodeBlockNode = function() {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	this.type = \"code_block\";\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsyLog(\"EVAL BLOCK \" + this.children.length);\n"
	"\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var lastVal = null;\n"
	"		var i = 0;\n"
	"\n"
	"		function evalChildren(children, done) {\n"
	"			if (i < children.length) {\n"
	"				// bitsyLog(\">> CHILD \" + i);\n"
	"				children[i].Eval(environment, function(val) {\n"
	"					// bitsyLog(\"<< CHILD \" + i);\n"
	"					lastVal = val;\n"
	"					i++;\n"
	"					evalChildren(children,done);\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var self = this;\n"
	"		evalChildren(this.children, function() {\n"
	"			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"				events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"			}\n"
	"\n"
	"			onReturn(lastVal);\n"
	"		});\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		if(depth === undefined) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		// bitsyLog(\"SERIALIZE BLOCK!!!\");\n"
	"		// bitsyLog(depth);\n"
	"		// bitsyLog(doIndentFirstLine);\n"
	"\n"
	"		var str = \"{\"; // todo: increase scope of Sym?\n"
	"\n"
	"		// TODO : do code blocks ever have more than one child anymore????\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			var curNode = this.children[i];\n"
	"			str += curNode.Serialize(depth);\n"
	"		}\n"
	"\n"
	"		str += \"}\";\n"
	"\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function isInlineCode(node) {\n"
	"	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);\n"
	"}\n"
	"\n"
	"function isUndefinedBlock(node) {\n"
	"	return node.type === \"code_block\" && node.children.length > 0 && node.children[0].type === \"undefined\";\n"
	"}\n"
	"\n"
	"var textEffectBlockNames = [\"clr1\", \"clr2\", \"clr3\", \"wvy\", \"shk\", \"rbw\", \"printSprite\", \"printItem\", \"printTile\", \"print\", \"say\", \"br\"];\n"
	"function isTextEffectBlock(node) {\n"
	"	if (node.type === \"code_block\") {\n"
	"		if (node.children.length > 0 && node.children[0].type === \"function\") {\n"
	"			var func = node.children[0];\n"
	"			return textEffectBlockNames.indexOf(func.name) != -1;\n"
	"		}\n"
	"	}\n"
	"	return false;\n"
	"}\n"
	"\n"
	"var listBlockTypes = [\"sequence\", \"cycle\", \"shuffle\", \"if\"];\n"
	"function isMultilineListBlock(node) {\n"
	"	if (node.type === \"code_block\") {\n"
	"		if (node.children.length > 0) {\n"
	"			var child = node.children[0];\n"
	"			return listBlockTypes.indexOf(child.type) != -1;\n"
	"		}\n"
	"	}\n"
	"	return false;\n"
	"}\n"
	"\n"
	"// for round-tripping undefined code through the parser (useful for hacks!)\n"
	"var UndefinedNode = function(sourceStr) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"	this.type = \"undefined\";\n"
	"	this.source = sourceStr;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		addOrRemoveTextEffect(environment, \"_debug_highlight\");\n"
	"		printFunc(environment, [\"{\" + sourceStr + \"}\"], function() {\n"
	"			onReturn(null);\n"
	"		});\n"
	"		addOrRemoveTextEffect(environment, \"_debug_highlight\");\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		return this.source;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return \"undefined\" + \" \" + this.GetId();\n"
	"	}\n"
	"}\n"
	"\n"
	"var FuncNode = function(name,args) {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	// Object.assign( this, new Runnable() );\n"
	"	this.type = \"function\";\n"
	"	this.name = name;\n"
	"	this.args = args;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var self = this; // hack to deal with scope (TODO : move up higher?)\n"
	"\n"
	"		var argumentValues = [];\n"
	"		var i = 0;\n"
	"\n"
	"		function evalArgs(args, done) {\n"
	"			// TODO : really hacky way to make we get the first\n"
	"			// symbol's NAME instead of its variable value\n"
	"			// if we are trying to do something with a property\n"
	"			if (self.name === \"property\" && i === 0 && i < args.length) {\n"
	"				if (args[i].type === \"variable\") {\n"
	"					argumentValues.push(args[i].name);\n"
	"					i++;\n"
	"				}\n"
	"				else {\n"
	"					// first argument for a property MUST be a variable symbol\n"
	"					// -- so skip everything if it's not!\n"
	"					i = args.length;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (i < args.length) {\n"
	"				// Evaluate each argument\n"
	"				args[i].Eval(\n"
	"					environment,\n"
	"					function(val) {\n"
	"						argumentValues.push(val);\n"
	"						i++;\n"
	"						evalArgs(args, done);\n"
	"					});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		evalArgs(\n"
	"			this.args,\n"
	"			function() {\n"
	"				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"					events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"				}\n"
	"\n"
	"				environment.EvalFunction(self.name, argumentValues, onReturn);\n"
	"			});\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var isDialogBlock = this.parent.type === \"dialog_block\";\n"
	"		if (isDialogBlock && this.name === \"print\") {\n"
	"			// TODO this could cause problems with \"real\" print functions\n"
	"			return this.args[0].value; // first argument should be the text of the {print} func\n"
	"		}\n"
	"		else if (isDialogBlock && this.name === \"br\") {\n"
	"			return \"\\n\";\n"
	"		}\n"
	"		else {\n"
	"			var str = \"\";\n"
	"			str += this.name;\n"
	"			for(var i = 0; i < this.args.length; i++) {\n"
	"				str += \" \";\n"
	"				str += this.args[i].Serialize(depth);\n"
	"			}\n"
	"			return str;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.name + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var LiteralNode = function(value) {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	// Object.assign( this, new Runnable() );\n"
	"	this.type = \"literal\";\n"
	"	this.value = value;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		onReturn(this.value);\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"\n"
	"		if (this.value === null) {\n"
	"			return str;\n"
	"		}\n"
	"\n"
	"		if (typeof this.value === \"string\") {\n"
	"			str += '\"';\n"
	"		}\n"
	"\n"
	"		str += this.value;\n"
	"\n"
	"		if (typeof this.value === \"string\") {\n"
	"			str += '\"';\n"
	"		}\n"
	"\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.value + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var VarNode = function(name) {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	// Object.assign( this, new Runnable() );\n"
	"	this.type = \"variable\";\n"
	"	this.name = name;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		// bitsyLog(\"EVAL \" + this.name + \" \" + environment.HasVariable(this.name) + \" \" + environment.GetVariable(this.name));\n"
	"		if( environment.HasVariable(this.name) )\n"
	"			onReturn( environment.GetVariable( this.name ) );\n"
	"		else\n"
	"			onReturn(null); // not a valid variable -- return null and hope that's ok\n"
	"	} // TODO: might want to store nodes in the variableMap instead of values???\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\" + this.name;\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.name + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var ExpNode = function(operator, left, right) {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	this.type = \"operator\";\n"
	"	this.operator = operator;\n"
	"	this.left = left;\n"
	"	this.right = right;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		// bitsyLog(\"EVAL \" + this.operator);\n"
	"		var self = this; // hack to deal with scope\n"
	"		environment.EvalOperator( this.operator, this.left, this.right, \n"
	"			function(val){\n"
	"				// bitsyLog(\"EVAL EXP \" + self.operator + \" \" + val);\n"
	"				onReturn(val);\n"
	"			} );\n"
	"		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var isNegativeNumber = this.operator === \"-\" && this.left.type === \"literal\" && this.left.value === null;\n"
	"\n"
	"		if (!isNegativeNumber) {\n"
	"			var str = \"\";\n"
	"\n"
	"			if (this.left != undefined && this.left != null) {\n"
	"				str += this.left.Serialize(depth) + \" \";\n"
	"			}\n"
	"\n"
	"			str += this.operator;\n"
	"\n"
	"			if (this.right != undefined && this.right != null) {\n"
	"				str += \" \" + this.right.Serialize(depth);\n"
	"			}\n"
	"\n"
	"			return str;\n"
	"		}\n"
	"		else {\n"
	"			return this.operator + this.right.Serialize(depth); // hacky but seems to work\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit( this, depth );\n"
	"		if(this.left != null)\n"
	"			this.left.VisitAll( visitor, depth + 1 );\n"
	"		if(this.right != null)\n"
	"			this.right.VisitAll( visitor, depth + 1 );\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.operator + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var SequenceBase = function() {\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		str += this.type + \"\\n\";\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			str += leadingWhitespace(depth + 1) + Sym.List + \" \";\n"
	"			str += this.children[i].Serialize(depth + 2);\n"
	"			str += \"\\n\";\n"
	"		}\n"
	"		str += leadingWhitespace(depth);\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll( visitor, depth + 1 );\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var SequenceNode = function(options) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"	Object.assign(this, new SequenceBase());\n"
	"	this.type = \"sequence\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsyLog(\"SEQUENCE \" + index);\n"
	"		this.children[index].Eval(environment, onReturn);\n"
	"\n"
	"		var next = index + 1;\n"
	"		if (next < this.children.length) {\n"
	"			index = next;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"var CycleNode = function(options) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"	Object.assign(this, new SequenceBase());\n"
	"	this.type = \"cycle\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsyLog(\"CYCLE \" + index);\n"
	"		this.children[index].Eval(environment, onReturn);\n"
	"\n"
	"		var next = index + 1;\n"
	"		if (next < this.children.length) {\n"
	"			index = next;\n"
	"		}\n"
	"		else {\n"
	"			index = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"var ShuffleNode = function(options) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"	Object.assign(this, new SequenceBase());\n"
	"	this.type = \"shuffle\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var optionsShuffled = [];\n"
	"	function shuffle(options) {\n"
	"		optionsShuffled = [];\n"
	"		var optionsUnshuffled = options.slice();\n"
	"		while (optionsUnshuffled.length > 0) {\n"
	"			var i = Math.floor(Math.random() * optionsUnshuffled.length);\n"
	"			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);\n"
	"		}\n"
	"	}\n"
	"	shuffle(this.children);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		optionsShuffled[index].Eval(environment, onReturn);\n"
	"		\n"
	"		index++;\n"
	"		if (index >= this.children.length) {\n"
	"			shuffle(this.children);\n"
	"			index = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"// TODO : rename? ConditionalNode?\n"
	"var IfNode = function(conditions, results, isSingleLine) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"	this.type = \"if\";\n"
	"\n"
	"	for (var i = 0; i < conditions.length; i++) {\n"
	"		this.AddChild(new ConditionPairNode(conditions[i], results[i]));\n"
	"	}\n"
	"\n"
	"	var self = this;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsyLog(\"EVAL IF\");\n"
	"		var i = 0;\n"
	"		function TestCondition() {\n"
	"			self.children[i].Eval(environment, function(result) {\n"
	"				if (result.conditionValue == true) {\n"
	"					onReturn(result.resultValue);\n"
	"				}\n"
	"				else if (i+1 < self.children.length) {\n"
	"					i++;\n"
	"					TestCondition();\n"
	"				}\n"
	"				else {\n"
	"					onReturn(null);\n"
	"				}\n"
	"			});\n"
	"		};\n"
	"		TestCondition();\n"
	"	}\n"
	"\n"
	"	if (isSingleLine === undefined) {\n"
	"		isSingleLine = false; // This is just for serialization\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		if(isSingleLine) {\n"
	"			// HACKY - should I even keep this mode???\n"
	"			str += this.children[0].children[0].Serialize() + \" ? \" + this.children[0].children[1].Serialize();\n"
	"			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {\n"
	"				str += \" \" + Sym.ElseExp + \" \" + this.children[1].children[1].Serialize();\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			str += \"\\n\";\n"
	"			for (var i = 0; i < this.children.length; i++) {\n"
	"				str += this.children[i].Serialize(depth);\n"
	"			}\n"
	"			str += leadingWhitespace(depth);\n"
	"		}\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.IsSingleLine = function() {\n"
	"		return isSingleLine;\n"
	"	}\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll(visitor, depth + 1);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.mode + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var ConditionPairNode = function(condition, result) {\n"
	"	Object.assign(this, new TreeRelationship());\n"
	"\n"
	"	this.type = \"condition_pair\";\n"
	"\n"
	"	this.AddChild(condition);\n"
	"	this.AddChild(result);\n"
	"\n"
	"	var self = this;\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		self.children[0].Eval(environment, function(conditionSuccess) {\n"
	"			if (conditionSuccess) {\n"
	"				self.children[1].Eval(environment, function(resultValue) {\n"
	"					onReturn({ conditionValue:true, resultValue:resultValue });\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				onReturn({ conditionValue:false });\n"
	"			}\n"
	"		});\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		str += leadingWhitespace(depth + 1);\n"
	"		str += Sym.List + \" \" + this.children[0].Serialize(depth) + \" \" + Sym.ConditionEnd + Sym.Linebreak;\n"
	"		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll(visitor, depth + 1);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	}\n"
	"}\n"
	"\n"
	"var ElseNode = function() {\n"
	"	Object.assign( this, new TreeRelationship() );\n"
	"	this.type = Sym.Else;\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		onReturn(true);\n"
	"	}\n"
	"\n"
	"	this.Serialize = function() {\n"
	"		return Sym.Else;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.mode + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var Sym = {\n"
	"	DialogOpen : '\"\"\"',\n"
	"	DialogClose : '\"\"\"',\n"
	"	CodeOpen : \"{\",\n"
	"	CodeClose : \"}\",\n"
	"	Linebreak : \"\\n\", // just call it \"break\" ?\n"
	"	Separator : \":\",\n"
	"	List : \"-\",\n"
	"	String : '\"',\n"
	"	ConditionEnd : \"?\",\n"
	"	Else : \"else\",\n"
	"	ElseExp : \":\", // special shorthand for expressions (deprecate?)\n"
	"	Set : \"=\",\n"
	"	Operators : [\"==\", \">=\", \"<=\", \">\", \"<\", \"-\", \"+\", \"/\", \"*\"], // operators need to be in reverse order of precedence\n"
	"};\n"
	"\n"
	"var Parser = function(env) {\n"
	"	var environment = env;\n"
	"\n"
	"	this.Parse = function(scriptStr, rootId) {\n"
	"		var rootNode = new DialogBlockNode();\n"
	"		rootNode.rootId = rootId;\n"
	"		var state = new ParserState(rootNode, scriptStr);\n"
	"\n"
	"		bitsyLog(scriptStr);\n"
	"		bitsyLog(state.Source());\n"
	"\n"
	"		if (state.MatchAhead(Sym.DialogOpen)) {\n"
	"			// multi-line dialog block\n"
	"			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);\n"
	"			rootNode = new DialogBlockNode();\n"
	"			rootNode.rootId = rootId; // hacky!!\n"
	"			state = new ParserState(rootNode, dialogStr);\n"
	"			state = ParseDialog(state);\n"
	"		}\n"
	"		else {\n"
	"			// single-line dialog block\n"
	"			state = ParseDialog(state);\n"
	"		}\n"
	"\n"
	"		return state.rootNode;\n"
	"	};\n"
	"\n"
	"	var ParserState = function( rootNode, str ) {\n"
	"		this.rootNode = rootNode;\n"
	"		this.curNode = this.rootNode;\n"
	"\n"
	"		var sourceStr = str;\n"
	"		var i = 0;\n"
	"		this.Index = function() { return i; };\n"
	"		this.Count = function() { return sourceStr.length; };\n"
	"		this.Done = function() { return i >= sourceStr.length; };\n"
	"		this.Char = function() { return sourceStr[i]; };\n"
	"		this.Step = function(n) { if(n===undefined) n=1; i += n; };\n"
	"		this.MatchAhead = function(str) {\n"
	"			// bitsyLog(str);\n"
	"			str = \"\" + str; // hack to turn single chars into strings\n"
	"			// bitsyLog(str);\n"
	"			// bitsyLog(str.length);\n"
	"			for (var j = 0; j < str.length; j++) {\n"
	"				if (i + j >= sourceStr.length) {\n"
	"					return false;\n"
	"				}\n"
	"				else if (str[j] != sourceStr[i+j]) {\n"
	"					return false;\n"
	"				}\n"
	"			}\n"
	"			return true;\n"
	"		}\n"
	"		this.Peak = function(end) {\n"
	"			var str = \"\";\n"
	"			var j = i;\n"
	"			// bitsyLog(j);\n"
	"			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {\n"
	"				str += sourceStr[j];\n"
	"				j++;\n"
	"			}\n"
	"			// bitsyLog(\"PEAK ::\" + str + \"::\");\n"
	"			return str;\n"
	"		}\n"
	"		this.ConsumeBlock = function(open, close, includeSymbols) {\n"
	"			if (includeSymbols === undefined || includeSymbols === null) {\n"
	"				includeSymbols = false;\n"
	"			}\n"
	"\n"
	"			var startIndex = i;\n"
	"\n"
	"			var matchCount = 0;\n"
	"			if (this.MatchAhead(open)) {\n"
	"				matchCount++;\n"
	"				this.Step(open.length);\n"
	"			}\n"
	"\n"
	"			while (matchCount > 0 && !this.Done()) {\n"
	"				if (this.MatchAhead(close)) {\n"
	"					matchCount--;\n"
	"					this.Step( close.length );\n"
	"				}\n"
	"				else if (this.MatchAhead(open)) {\n"
	"					matchCount++;\n"
	"					this.Step(open.length);\n"
	"				}\n"
	"				else {\n"
	"					this.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (includeSymbols) {\n"
	"				return sourceStr.slice(startIndex, i);\n"
	"			}\n"
	"			else {\n"
	"				return sourceStr.slice(startIndex + open.length, i - close.length);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		this.Print = function() { bitsyLog(sourceStr); };\n"
	"		this.Source = function() { return sourceStr; };\n"
	"	};\n"
	"\n"
	"	/*\n"
	"		ParseDialog():\n"
	"		This function adds {print} nodes and linebreak {br} nodes to display text,\n"
	"		interleaved with bracketed code nodes for functions and flow control,\n"
	"		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.\n"
	"		The parsing of those code blocks is handled by ParseCode.\n"
	"\n"
	"		Note on parsing newline characters:\n"
	"		- there should be an implicit linebreak {br} after each dialog line\n"
	"		- a \"dialog line\" is defined as any line that either:\n"
	"			- 1) contains dialog text (any text outside of a code block)\n"
	"			- 2) is entirely empty (no text, no code)\n"
	"			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)\n"
	"		- lines *only* containing {code} blocks are not dialog lines\n"
	"\n"
	"		NOTE TO SELF: all the state I'm storing in here feels like\n"
	"		evidence that the parsing system kind of broke down at this point :(\n"
	"		Maybe it would feel better if I move into the \"state\" object\n"
	"	*/\n"
	"	function ParseDialog(state) {\n"
	"		var curLineNodeList = [];\n"
	"		var curText = \"\";\n"
	"		var curLineIsEmpty = true;\n"
	"		var curLineContainsDialogText = false;\n"
	"		var prevLineIsDialogLine = false;\n"
	"\n"
	"		var curLineIsDialogLine = function() {\n"
	"			return curLineContainsDialogText || curLineIsEmpty;\n"
	"		}\n"
	"\n"
	"		var resetLineStateForNewLine = function() {\n"
	"			prevLineIsDialogLine = curLineIsDialogLine();\n"
	"			curLineContainsDialogText = false;\n"
	"			curLineIsEmpty = true;\n"
	"			curText = \"\";\n"
	"			curLineNodeList = [];\n"
	"		}\n"
	"\n"
	"		var tryAddTextNodeToList = function() {\n"
	"			if (curText.length > 0) {\n"
	"				var printNode = new FuncNode(\"print\", [new LiteralNode(curText)]);\n"
	"				curLineNodeList.push(printNode);\n"
	"\n"
	"				curText = \"\";\n"
	"				curLineIsEmpty = false;\n"
	"				curLineContainsDialogText = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var addCodeNodeToList = function() {\n"
	"			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);\n"
	"			var codeState = new ParserState(new CodeBlockNode(), codeSource);\n"
	"			codeState = ParseCode(codeState);\n"
	"			var codeBlockNode = codeState.rootNode;\n"
	"			curLineNodeList.push(codeBlockNode);\n"
	"\n"
	"			curLineIsEmpty = false;\n"
	"\n"
	"			// lists count as dialog text, because they can contain it\n"
	"			if (isMultilineListBlock(codeBlockNode)) {\n"
	"				curLineContainsDialogText = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var tryAddLinebreakNodeToList = function() {\n"
	"			if (prevLineIsDialogLine) {\n"
	"				var linebreakNode = new FuncNode(\"br\", []);\n"
	"				curLineNodeList.unshift(linebreakNode);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var addLineNodesToParent = function() {\n"
	"			for (var i = 0; i < curLineNodeList.length; i++) {\n"
	"				state.curNode.AddChild(curLineNodeList[i]);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			if (state.MatchAhead(Sym.CodeOpen)) { // process code block\n"
	"				// add any buffered text to a print node, and parse the code\n"
	"				tryAddTextNodeToList();\n"
	"				addCodeNodeToList();\n"
	"			}\n"
	"			else if (state.MatchAhead(Sym.Linebreak)) { // process new line\n"
	"				// add any buffered text to a print node, \n"
	"				// and add a linebreak if we are between two dialog lines\n"
	"				tryAddTextNodeToList();\n"
	"				tryAddLinebreakNodeToList();\n"
	"\n"
	"				// since we've reached the end of a line\n"
	"				// add stored nodes for this line to the parent node we are building,\n"
	"				// and reset state for the next line\n"
	"				addLineNodesToParent();\n"
	"				resetLineStateForNewLine();\n"
	"\n"
	"				state.Step();\n"
	"			}\n"
	"			else {\n"
	"				// continue adding text to the current text buffer\n"
	"				curText += state.Char();\n"
	"				state.Step();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// to make sure we don't leave anything behind:\n"
	"		// add buffered text to a print node and add all nodes\n"
	"		// to the current parent node\n"
	"		tryAddTextNodeToList();\n"
	"		tryAddLinebreakNodeToList();\n"
	"		addLineNodesToParent();\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseDialogBlock(state) {\n"
	"		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );\n"
	"\n"
	"		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);\n"
	"		dialogState = ParseDialog( dialogState );\n"
	"\n"
	"		state.curNode.AddChild( dialogState.rootNode );\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	/*\n"
	"		ParseConditional():\n"
	"		A conditional contains a list of conditions that can be\n"
	"		evaluated to true or false, followed by more dialog\n"
	"		that will be evaluated if the condition is true. The first\n"
	"		true condition is the one that gets evaluated.\n"
	"	*/\n"
	"	function ParseConditional(state) {\n"
	"		var conditionStrings = [];\n"
	"		var resultStrings = [];\n"
	"		var curIndex = -1;\n"
	"		var requiredLeadingWhitespace = -1;\n"
	"\n"
	"		// TODO : very similar to sequence parsing - can we share anything?\n"
	"		function parseConditionalItemLine(state) {\n"
	"			var lineText = \"\";\n"
	"			var whitespaceCount = 0;\n"
	"			var isNewCondition = false;\n"
	"			var encounteredNonWhitespace = false;\n"
	"			var encounteredConditionEnd = false;\n"
	"\n"
	"			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {\n"
	"				// count whitespace until we hit the first non-whitespace character\n"
	"				if (!encounteredNonWhitespace) {\n"
	"					if (state.Char() === \" \" || state.Char() === \"\\t\") {\n"
	"						whitespaceCount++;\n"
	"					}\n"
	"					else {\n"
	"						encounteredNonWhitespace = true;\n"
	"\n"
	"						if (state.Char() === Sym.List) {\n"
	"							isNewCondition = true;\n"
	"							whitespaceCount += 2; // count the list seperator AND the following extra space\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// if this is the condition, we need to track whether we've\n"
	"				// reached the end of the condition\n"
	"				if (isNewCondition && !encounteredConditionEnd) {\n"
	"					if (state.Char() === Sym.ConditionEnd) {\n"
	"						encounteredConditionEnd = true;\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// add characters one at a time, unless it's a code block\n"
	"				// since code blocks can contain additional sequences inside\n"
	"				// them that will mess up our list item detection\n"
	"				if (state.Char() === Sym.CodeOpen) {\n"
	"					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);\n"
	"				}\n"
	"				else {\n"
	"					if (!encounteredConditionEnd) { // skip all characters including & after the condition end\n"
	"						lineText += state.Char();\n"
	"					}\n"
	"					state.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (state.Char() === Sym.Linebreak) {\n"
	"				state.Step();\n"
	"			}\n"
	"\n"
	"			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };\n"
	"		}\n"
	"\n"
	"		// TODO : this is copied from sequence parsing; share?\n"
	"		function trimLeadingWhitespace(text, trimLength) {\n"
	"			var textSplit = text.split(Sym.linebreak);\n"
	"			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });\n"
	"			return textSplit.join(Sym.linebreak);\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			var lineResults = parseConditionalItemLine(state);\n"
	"\n"
	"			if (lineResults.isNewCondition) {\n"
	"				requiredLeadingWhitespace = lineResults.whitespace;\n"
	"				curIndex++;\n"
	"				conditionStrings[curIndex] = \"\";\n"
	"				resultStrings[curIndex] = \"\";\n"
	"			}\n"
	"\n"
	"			// to avoid extra newlines in nested conditionals, only count lines\n"
	"			// that at least match the whitespace count of the initial line\n"
	"			// NOTE: see the comment in sequence parsing for more details\n"
	"			if (lineResults.whitespace >= requiredLeadingWhitespace) {\n"
	"				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);\n"
	"\n"
	"				if (lineResults.isNewCondition) {\n"
	"					conditionStrings[curIndex] += trimmedText;\n"
	"				}\n"
	"				else {\n"
	"					resultStrings[curIndex] += trimmedText + Sym.Linebreak;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// hack: cut off the trailing newlines from all the result strings\n"
	"		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });\n"
	"\n"
	"		var conditions = [];\n"
	"		for (var i = 0; i < conditionStrings.length; i++) {\n"
	"			var str = conditionStrings[i].trim();\n"
	"			if (str === Sym.Else) {\n"
	"				conditions.push(new ElseNode());\n"
	"			}\n"
	"			else {\n"
	"				var exp = CreateExpression(str);\n"
	"				conditions.push(exp);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var results = [];\n"
	"		for (var i = 0; i < resultStrings.length; i++) {\n"
	"			var str = resultStrings[i];\n"
	"			var dialogBlockState = new ParserState(new DialogBlockNode(), str);\n"
	"			dialogBlockState = ParseDialog(dialogBlockState);\n"
	"			var dialogBlock = dialogBlockState.rootNode;\n"
	"			results.push(dialogBlock);\n"
	"		}\n"
	"\n"
	"		state.curNode.AddChild(new IfNode(conditions, results));\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsSequence(str) {\n"
	"		// bitsyLog(\"IsSequence? \" + str);\n"
	"		return str === \"sequence\" || str === \"cycle\" || str === \"shuffle\";\n"
	"	}\n"
	"\n"
	"	/*\n"
	"		ParseSequence():\n"
	"		Sequence nodes contain a list of dialog block nodes. The order those\n"
	"		nodes are evaluated is determined by the type of sequence:\n"
	"		- sequence: each child node evaluated once in order\n"
	"		- cycle: repeats from the beginning after all nodes evaluate\n"
	"		- shuffle: evaluate in a random order\n"
	"\n"
	"		Each item in a sequence is sepearated by a \"-\" character.\n"
	"		The seperator must come at the beginning of the line,\n"
	"		but may be preceded by whitespace (in any amount).\n"
	"\n"
	"		About whitespace: Whitespace at the start of a line\n"
	"		is ignored if it less than or equal to the count of\n"
	"		whitespace that preceded the list separator (\"-\") at\n"
	"		the start of that item. (The count also includes the\n"
	"		seperator and the extra space after the seperator.)\n"
	"	 */\n"
	"	function ParseSequence(state, sequenceType) {\n"
	"		var itemStrings = [];\n"
	"		var curItemIndex = -1; // -1 indicates not reading an item yet\n"
	"		var requiredLeadingWhitespace = -1;\n"
	"\n"
	"		function parseSequenceItemLine(state) {\n"
	"			var lineText = \"\";\n"
	"			var whitespaceCount = 0;\n"
	"			var isNewListItem = false;\n"
	"			var encounteredNonWhitespace = false;\n"
	"\n"
	"			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {\n"
	"				// count whitespace until we hit the first non-whitespace character\n"
	"				if (!encounteredNonWhitespace) {\n"
	"					if (state.Char() === \" \" || state.Char() === \"\\t\") {\n"
	"						whitespaceCount++;\n"
	"					}\n"
	"					else {\n"
	"						encounteredNonWhitespace = true;\n"
	"\n"
	"						if (state.Char() === Sym.List) {\n"
	"							isNewListItem = true;\n"
	"							whitespaceCount += 2; // count the list seperator AND the following extra space\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// add characters one at a time, unless it's a code block\n"
	"				// since code blocks can contain additional sequences inside\n"
	"				// them that will mess up our list item detection\n"
	"				if (state.Char() === Sym.CodeOpen) {\n"
	"					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);\n"
	"				}\n"
	"				else {\n"
	"					lineText += state.Char();\n"
	"					state.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (state.Char() === Sym.Linebreak) {\n"
	"				state.Step();\n"
	"			}\n"
	"\n"
	"			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };\n"
	"		}\n"
	"\n"
	"		function trimLeadingWhitespace(text, trimLength) {\n"
	"			// the split and join is necessary because a single \"line\"\n"
	"			// can contain sequences that may contain newlines of their own\n"
	"			// (we treat them all as one \"line\" for sequence parsing purposes)\n"
	"			var textSplit = text.split(Sym.linebreak);\n"
	"			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });\n"
	"			return textSplit.join(Sym.linebreak);\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			var lineResults = parseSequenceItemLine(state);\n"
	"\n"
	"			if (lineResults.isNewListItem) {\n"
	"				requiredLeadingWhitespace = lineResults.whitespace;\n"
	"				curItemIndex++;\n"
	"				itemStrings[curItemIndex] = \"\";\n"
	"			}\n"
	"\n"
	"			// to avoid double counting closing lines (empty ones ending in a curly brace)\n"
	"			// we only allow lines that have at least as much whitespace as the start of the list item\n"
	"			// TODO : I think right now this leads to a bug if the list item's indentation is less than\n"
	"			// its parent code block... hopefully that won't be a big deal for now\n"
	"			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but\n"
	"			// that would require more consideration and testing)\n"
	"			if (lineResults.whitespace >= requiredLeadingWhitespace) {\n"
	"				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);\n"
	"				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// a bit hacky: cut off the trailing newlines from all the items\n"
	"		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });\n"
	"\n"
	"		var options = [];\n"
	"		for (var i = 0; i < itemStrings.length; i++) {\n"
	"			var str = itemStrings[i];\n"
	"			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);\n"
	"			dialogBlockState = ParseDialog(dialogBlockState);\n"
	"			var dialogBlock = dialogBlockState.rootNode;\n"
	"			options.push(dialogBlock);\n"
	"		}\n"
	"\n"
	"		if (sequenceType === \"sequence\") {\n"
	"			state.curNode.AddChild(new SequenceNode(options));\n"
	"		}\n"
	"		else if (sequenceType === \"cycle\") {\n"
	"			state.curNode.AddChild(new CycleNode(options));\n"
	"		}\n"
	"		else if (sequenceType === \"shuffle\") {\n"
	"			state.curNode.AddChild(new ShuffleNode(options));\n"
	"		}\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseFunction(state, funcName) {\n"
	"		bitsyLog(\"~~~ PARSE FUNCTION \" + funcName);\n"
	"\n"
	"		var args = [];\n"
	"\n"
	"		var curSymbol = \"\";\n"
	"		function OnSymbolEnd() {\n"
	"			curSymbol = curSymbol.trim();\n"
	"			// bitsyLog(\"PARAMTER \" + curSymbol);\n"
	"			args.push( StringToValue(curSymbol) );\n"
	"			// bitsyLog(args);\n"
	"			curSymbol = \"\";\n"
	"		}\n"
	"\n"
	"		while( !( state.Char() === \"\\n\" || state.Done() ) ) {\n"
	"			if( state.MatchAhead(Sym.CodeOpen) ) {\n"
	"				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));\n"
	"				codeBlockState = ParseCode( codeBlockState );\n"
	"				var codeBlock = codeBlockState.rootNode;\n"
	"				args.push( codeBlock );\n"
	"				curSymbol = \"\";\n"
	"			}\n"
	"			else if( state.MatchAhead(Sym.String) ) {\n"
	"				/* STRING LITERAL */\n"
	"				var str = state.ConsumeBlock(Sym.String, Sym.String);\n"
	"				// bitsyLog(\"STRING \" + str);\n"
	"				args.push( new LiteralNode(str) );\n"
	"				curSymbol = \"\";\n"
	"			}\n"
	"			else if(state.Char() === \" \" && curSymbol.length > 0) {\n"
	"				OnSymbolEnd();\n"
	"			}\n"
	"			else {\n"
	"				curSymbol += state.Char();\n"
	"			}\n"
	"			state.Step();\n"
	"		}\n"
	"\n"
	"		if(curSymbol.length > 0) {\n"
	"			OnSymbolEnd();\n"
	"		}\n"
	"\n"
	"		state.curNode.AddChild( new FuncNode( funcName, args ) );\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsValidVariableName(str) {\n"
	"		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n"
	"		var isValid = reg.test(str);\n"
	"		// bitsyLog(\"VALID variable??? \" + isValid);\n"
	"		return isValid;\n"
	"	}\n"
	"\n"
	"	function StringToValue(valStr) {\n"
	"		if(valStr[0] === Sym.CodeOpen) {\n"
	"			// CODE BLOCK!!!\n"
	"			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky\n"
	"			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);\n"
	"			codeBlockState = ParseCode( codeBlockState );\n"
	"			return codeBlockState.rootNode;\n"
	"		}\n"
	"		else if(valStr[0] === Sym.String) {\n"
	"			// STRING!!\n"
	"			// bitsyLog(\"STRING\");\n"
	"			var str = \"\";\n"
	"			var i = 1;\n"
	"			while (i < valStr.length && valStr[i] != Sym.String) {\n"
	"				str += valStr[i];\n"
	"				i++;\n"
	"			}\n"
	"			// bitsyLog(str);\n"
	"			return new LiteralNode( str );\n"
	"		}\n"
	"		else if(valStr === \"true\") {\n"
	"			// BOOL\n"
	"			return new LiteralNode( true );\n"
	"		}\n"
	"		else if(valStr === \"false\") {\n"
	"			// BOOL\n"
	"			return new LiteralNode( false );\n"
	"		}\n"
	"		else if( !isNaN(parseFloat(valStr)) ) {\n"
	"			// NUMBER!!\n"
	"			// bitsyLog(\"NUMBER!!! \" + valStr);\n"
	"			return new LiteralNode( parseFloat(valStr) );\n"
	"		}\n"
	"		else if(IsValidVariableName(valStr)) {\n"
	"			// VARIABLE!!\n"
	"			// bitsyLog(\"VARIABLE\");\n"
	"			return new VarNode(valStr); // TODO : check for valid potential variables\n"
	"		}\n"
	"		else {\n"
	"			// uh oh\n"
	"			return new LiteralNode(null);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function CreateExpression(expStr) {\n"
	"		expStr = expStr.trim();\n"
	"\n"
	"		function IsInsideString(index) {\n"
	"			var inString = false;\n"
	"			for(var i = 0; i < expStr.length; i++) {\n"
	"				if(expStr[i] === Sym.String)\n"
	"					inString = !inString;\n"
	"\n"
	"				if(index === i)\n"
	"					return inString;\n"
	"			}\n"
	"			return false;\n"
	"		}\n"
	"\n"
	"		function IsInsideCode(index) {\n"
	"			var count = 0;\n"
	"			for(var i = 0; i < expStr.length; i++) {\n"
	"				if(expStr[i] === Sym.CodeOpen)\n"
	"					count++;\n"
	"				else if(expStr[i] === Sym.CodeClose)\n"
	"					count--;\n"
	"\n"
	"				if(index === i)\n"
	"					return count > 0;\n"
	"			}\n"
	"			return false;\n"
	"		}\n"
	"\n"
	"		var operator = null;\n"
	"\n"
	"		// set is special because other operator can look like it, and it has to go first in the order of operations\n"
	"		var setIndex = expStr.indexOf(Sym.Set);\n"
	"		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator\n"
	"			if( expStr[setIndex+1] != \"=\" && expStr[setIndex-1] != \">\" && expStr[setIndex-1] != \"<\" ) {\n"
	"				// ok it actually IS a set operator and not ==, >=, or <=\n"
	"				operator = Sym.Set;\n"
	"				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing\n"
	"				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);\n"
	"				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );\n"
	"				var exp = new ExpNode( operator, left, right );\n"
	"				return exp;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// special if \"expression\" for single-line if statements\n"
	"		var ifIndex = expStr.indexOf(Sym.ConditionEnd);\n"
	"		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {\n"
	"			operator = Sym.ConditionEnd;\n"
	"			var conditionStr = expStr.substring(0,ifIndex).trim();\n"
	"			var conditions = [ CreateExpression(conditionStr) ];\n"
	"\n"
	"			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);\n"
	"			var results = [];\n"
	"			function AddResult(str) {\n"
	"				var dialogBlockState = new ParserState(new DialogBlockNode(), str);\n"
	"				dialogBlockState = ParseDialog( dialogBlockState );\n"
	"				var dialogBlock = dialogBlockState.rootNode;\n"
	"				results.push( dialogBlock );\n"
	"			}\n"
	"\n"
	"			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?\n"
	"			if(elseIndex > -1) {\n"
	"				conditions.push( new ElseNode() );\n"
	"\n"
	"				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);\n"
	"				var resultStr = resultStr.substring(0,elseIndex);\n"
	"\n"
	"				AddResult( resultStr.trim() );\n"
	"				AddResult( elseStr.trim() );\n"
	"			}\n"
	"			else {\n"
	"				AddResult( resultStr.trim() );\n"
	"			}\n"
	"\n"
	"			return new IfNode( conditions, results, true /*isSingleLine*/ );\n"
	"		}\n"
	"\n"
	"		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {\n"
	"			var opSym = Sym.Operators[i];\n"
	"			var opIndex = expStr.indexOf( opSym );\n"
	"			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {\n"
	"				operator = opSym;\n"
	"				var left = CreateExpression( expStr.substring(0,opIndex) );\n"
	"				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );\n"
	"				var exp = new ExpNode( operator, left, right );\n"
	"				return exp;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if( operator == null ) {\n"
	"			return StringToValue(expStr);\n"
	"		}\n"
	"	}\n"
	"	this.CreateExpression = CreateExpression;\n"
	"\n"
	"	function IsWhitespace(str) {\n"
	"		return ( str === \" \" || str === \"\\t\" || str === \"\\n\" );\n"
	"	}\n"
	"\n"
	"	function IsExpression(str) {\n"
	"		var tempState = new ParserState(null, str); // hacky\n"
	"		var textOutsideCodeBlocks = \"\";\n"
	"\n"
	"		while (!tempState.Done()) {\n"
	"			if (tempState.MatchAhead(Sym.CodeOpen)) {\n"
	"				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);\n"
	"			}\n"
	"			else {\n"
	"				textOutsideCodeBlocks += tempState.Char();\n"
	"				tempState.Step();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||\n"
	"				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||\n"
	"				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));\n"
	"\n"
	"		return containsAnyExpressionOperators;\n"
	"	}\n"
	"\n"
	"	function IsLiteral(str) {\n"
	"		var isBool = str === \"true\" || str === \"false\";\n"
	"		var isNum = !isNaN(parseFloat(str));\n"
	"		var isStr = str[0] === '\"' && str[str.length-1] === '\"';\n"
	"		var isVar = IsValidVariableName(str);\n"
	"		var isEmpty = str.length === 0;\n"
	"		return isBool || isNum || isStr || isVar || isEmpty;\n"
	"	}\n"
	"\n"
	"	function ParseExpression(state) {\n"
	"		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing\n"
	"		// bitsyLog(\"EXPRESSION \" + line);\n"
	"		var exp = CreateExpression(line);\n"
	"		// bitsyLog(exp);\n"
	"		state.curNode.AddChild(exp);\n"
	"		state.Step(line.length);\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsConditionalBlock(state) {\n"
	"		var peakToFirstListSymbol = state.Peak([Sym.List]);\n"
	"\n"
	"		var foundListSymbol = peakToFirstListSymbol < state.Source().length;\n"
	"\n"
	"		var areAllCharsBeforeListWhitespace = true;\n"
	"		for (var i = 0; i < peakToFirstListSymbol.length; i++) {\n"
	"			if (!IsWhitespace(peakToFirstListSymbol[i])) {\n"
	"				areAllCharsBeforeListWhitespace = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);\n"
	"		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);\n"
	"		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;\n"
	"\n"
	"		return foundListSymbol && \n"
	"			areAllCharsBeforeListWhitespace && \n"
	"			hasNoLinebreakBetweenListAndConditionEnd;\n"
	"	}\n"
	"\n"
	"	function ParseCode(state) {\n"
	"		if (IsConditionalBlock(state)) {\n"
	"			state = ParseConditional(state);\n"
	"		}\n"
	"		else if (environment.HasFunction(state.Peak([\" \"]))) { // TODO --- what about newlines???\n"
	"			var funcName = state.Peak([\" \"]);\n"
	"			state.Step(funcName.length);\n"
	"			state = ParseFunction(state, funcName);\n"
	"		}\n"
	"		else if (IsSequence(state.Peak([\" \", Sym.Linebreak]))) {\n"
	"			var sequenceType = state.Peak([\" \", Sym.Linebreak]);\n"
	"			state.Step(sequenceType.length);\n"
	"			state = ParseSequence(state, sequenceType);\n"
	"		}\n"
	"		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {\n"
	"			state = ParseExpression(state);\n"
	"		}\n"
	"		else {\n"
	"			var undefinedSrc = state.Peak([]);\n"
	"			var undefinedNode = new UndefinedNode(undefinedSrc);\n"
	"			state.curNode.AddChild(undefinedNode);\n"
	"		}\n"
	"\n"
	"		// just go to the end now\n"
	"		while (!state.Done()) {\n"
	"			state.Step();\n"
	"		}\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseCodeBlock(state) {\n"
	"		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );\n"
	"		var codeState = new ParserState(new CodeBlockNode(), codeStr);\n"
	"		codeState = ParseCode( codeState );\n"
	"		state.curNode.AddChild( codeState.rootNode );\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"}\n"
	"\n"
	"} // Script()\n";

char* transition_js =
	"var TransitionManager = function() {\n"
	"	var transitionStart = null;\n"
	"	var transitionEnd = null;\n"
	"\n"
	"	var isTransitioning = false;\n"
	"	var transitionTime = 0; // milliseconds\n"
	"	var minStepTime = 125; // cap the frame rate\n"
	"	var curStep = 0;\n"
	"\n"
	"	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {\n"
	"		bitsyLog(\"--- START ROOM TRANSITION ---\");\n"
	"\n"
	"		curEffect = effectName;\n"
	"\n"
	"		var tmpRoom = player().room;\n"
	"		var tmpX = player().x;\n"
	"		var tmpY = player().y;\n"
	"\n"
	"		if (transitionEffects[curEffect].showPlayerStart) {\n"
	"			player().room = startRoom;\n"
	"			player().x = startX;\n"
	"			player().y = startY;\n"
	"		}\n"
	"		else {\n"
	"			player().room = \"_transition_none\"; // kind of hacky!!\n"
	"		}\n"
	"\n"
	"		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);\n"
	"		var startPalette = getPal(room[startRoom].pal);\n"
	"		var startImage = new PostProcessImage(startRoomPixels);\n"
	"		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);\n"
	"\n"
	"		if (transitionEffects[curEffect].showPlayerEnd) {\n"
	"			player().room = endRoom;\n"
	"			player().x = endX;\n"
	"			player().y = endY;\n"
	"		}\n"
	"		else {\n"
	"			player().room = \"_transition_none\";\n"
	"		}\n"
	"\n"
	"		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);\n"
	"		var endPalette = getPal(room[endRoom].pal);\n"
	"		var endImage = new PostProcessImage(endRoomPixels);\n"
	"		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);\n"
	"\n"
	"		isTransitioning = true;\n"
	"		transitionTime = 0;\n"
	"		curStep = 0;\n"
	"\n"
	"		player().room = tmpRoom;\n"
	"		player().x = tmpX;\n"
	"		player().y = tmpY;\n"
	"	}\n"
	"\n"
	"	this.UpdateTransition = function(dt) {\n"
	"		if (!isTransitioning) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		// todo : shouldn't need to set this every frame!\n"
	"		bitsySetGraphicsMode(0);\n"
	"\n"
	"		transitionTime += dt;\n"
	"\n"
	"		var maxStep = transitionEffects[curEffect].stepCount;\n"
	"\n"
	"		if (transitionTime >= minStepTime) {\n"
	"			curStep++;\n"
	"\n"
	"			var step = curStep;\n"
	"			bitsyLog(\"transition step \" + step);\n"
	"\n"
	"			if (transitionEffects[curEffect].paletteEffectFunc) {\n"
	"				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));\n"
	"				updatePaletteWithTileColors(colors);\n"
	"			}\n"
	"\n"
	"			bitsyDrawBegin(0);\n"
	"			for (var y = 0; y < 128; y++) {\n"
	"				for (var x = 0; x < 128; x++) {\n"
	"					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));\n"
	"					bitsyDrawPixel(color, x, y);\n"
	"				}\n"
	"			}\n"
	"			bitsyDrawEnd();\n"
	"\n"
	"			transitionTime = 0;\n"
	"		}\n"
	"\n"
	"		if (curStep >= (maxStep - 1)) {\n"
	"			isTransitioning = false;\n"
	"			transitionTime = 0;\n"
	"			transitionStart = null;\n"
	"			transitionEnd = null;\n"
	"			curStep = 0;\n"
	"\n"
	"			if (transitionCompleteCallback != null) {\n"
	"				transitionCompleteCallback();\n"
	"			}\n"
	"			transitionCompleteCallback = null;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.IsTransitionActive = function() {\n"
	"		return isTransitioning;\n"
	"	}\n"
	"\n"
	"	// todo : should this be part of the constructor?\n"
	"	var transitionCompleteCallback = null;\n"
	"	this.OnTransitionComplete = function(callback) {\n"
	"		if (isTransitioning) { // TODO : safety check necessary?\n"
	"			transitionCompleteCallback = callback;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var transitionEffects = {};\n"
	"	var curEffect = \"none\";\n"
	"	this.RegisterTransitionEffect = function(name, effect) {\n"
	"		transitionEffects[name] = effect;\n"
	"	}\n"
	"\n"
	"	this.RegisterTransitionEffect(\"none\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : false,\n"
	"		paletteEffectFunc : function() {},\n"
	"		pixelEffectFunc : function() {},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"fade_w\", { // TODO : have it linger on full white briefly?\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 6,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			var colors = [];\n"
	"\n"
	"			if (delta < 0.5) {\n"
	"				delta = delta / 0.5;\n"
	"\n"
	"				for (var i = 0; i < start.Palette.length; i++) {\n"
	"					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				delta = ((delta - 0.5) / 0.5);\n"
	"\n"
	"				for (var i = 0; i < end.Palette.length; i++) {\n"
	"					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));\n"
	"				}\n"
	"			}\n"
	"\n"
	"			return colors;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"fade_b\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 6,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			var colors = [];\n"
	"\n"
	"			if (delta < 0.5) {\n"
	"				delta = delta / 0.5;\n"
	"\n"
	"				for (var i = 0; i < start.Palette.length; i++) {\n"
	"					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				delta = ((delta - 0.5) / 0.5);\n"
	"\n"
	"				for (var i = 0; i < end.Palette.length; i++) {\n"
	"					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));\n"
	"				}\n"
	"			}\n"
	"\n"
	"			return colors;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"wave\", {\n"
	"		showPlayerStart : true,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 12,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);\n"
	"\n"
	"			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));\n"
	"			var freq = 4;\n"
	"			var size = 2 + (14 * waveDelta);\n"
	"			pixelX += Math.floor(Math.sin(offset / freq) * size);\n"
	"\n"
	"			if (pixelX < 0) {\n"
	"				pixelX += start.Image.Width;\n"
	"			}\n"
	"			else if (pixelX >= start.Image.Width) {\n"
	"				pixelX -= start.Image.Width;\n"
	"			}\n"
	"\n"
	"			var curImage = delta < 0.5 ? start.Image : end.Image;\n"
	"			return curImage.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			return delta < 0.5 ? start.Palette : end.Palette;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"tunnel\", {\n"
	"		showPlayerStart : true,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 12,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			if (delta <= 0.4) {\n"
	"				var tunnelDelta = 1 - (delta / 0.4);\n"
	"\n"
	"				var xDist = start.PlayerCenter.x - pixelX;\n"
	"				var yDist = start.PlayerCenter.y - pixelY;\n"
	"				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));\n"
	"\n"
	"				if (dist > start.Image.Width * tunnelDelta) {\n"
	"					return 0;\n"
	"				}\n"
	"				else {\n"
	"					return start.Image.GetPixel(pixelX, pixelY);\n"
	"				}\n"
	"			}\n"
	"			else if (delta <= 0.6) {\n"
	"				return 0;\n"
	"			}\n"
	"			else {\n"
	"				var tunnelDelta = (delta - 0.6) / 0.4;\n"
	"\n"
	"				var xDist = end.PlayerCenter.x - pixelX;\n"
	"				var yDist = end.PlayerCenter.y - pixelY;\n"
	"				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));\n"
	"\n"
	"				if (dist > end.Image.Width * tunnelDelta) {\n"
	"					return 0;\n"
	"				}\n"
	"				else {\n"
	"					return end.Image.GetPixel(pixelX, pixelY);\n"
	"				}\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			return delta < 0.5 ? start.Palette : end.Palette;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	function lerpPalettes(start, end, delta) {\n"
	"		var colors = [];\n"
	"\n"
	"		var maxLength = (start.Palette.length > end.Palette.length) ?\n"
	"			start.Palette.length : end.Palette.length;\n"
	"\n"
	"		for (var i = 0; i < maxLength; i++) {\n"
	"			if (i < start.Palette.length && i < end.Palette.length) {\n"
	"				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));\n"
	"			}\n"
	"			else if (i < start.Palette.length) {\n"
	"				colors.push(lerpColor(\n"
	"					start.Palette[i],\n"
	"					end.Palette[end.Palette.length - 1],\n"
	"					delta));\n"
	"			}\n"
	"			else if (i < end.Palette.length) {\n"
	"				colors.push(lerpColor(\n"
	"					start.Palette[start.Palette.length - 1],\n"
	"					end.Palette[i],\n"
	"					delta));\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return colors;\n"
	"	}\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_u\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);\n"
	"			var slidePixelY = pixelY + pixelOffset;\n"
	"\n"
	"			if (slidePixelY >= 0) {\n"
	"				return start.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelY += start.Image.Height;\n"
	"				return end.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_d\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = Math.floor(start.Image.Height * delta);\n"
	"			var slidePixelY = pixelY + pixelOffset;\n"
	"\n"
	"			if (slidePixelY < start.Image.Height) {\n"
	"				return start.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelY -= start.Image.Height;\n"
	"				return end.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_l\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);\n"
	"			var slidePixelX = pixelX + pixelOffset;\n"
	"\n"
	"			if (slidePixelX >= 0) {\n"
	"				return start.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelX += start.Image.Width;\n"
	"				return end.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_r\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = Math.floor(start.Image.Width * delta);\n"
	"			var slidePixelX = pixelX + pixelOffset;\n"
	"\n"
	"			if (slidePixelX < start.Image.Width) {\n"
	"				return start.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelX -= start.Image.Width;\n"
	"				return end.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	// todo : move to Renderer()?\n"
	"	function createRoomPixelBuffer(room) {\n"
	"		var pixelBuffer = [];\n"
	"\n"
	"		for (var i = 0; i < 128 * 128; i++) {\n"
	"			pixelBuffer.push(tileColorStartIndex);\n"
	"		}\n"
	"\n"
	"		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {\n"
	"			var frameData = sourceData[frameIndex];\n"
	"\n"
	"			for (var y = 0; y < tilesize; y++) {\n"
	"				for (var x = 0; x < tilesize; x++) {\n"
	"					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);\n"
	"					pixelBuffer[(((ty * tilesize) + y) * 128) + ((tx * tilesize) + x)] = color;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//draw tiles\n"
	"		for (i in room.tilemap) {\n"
	"			for (j in room.tilemap[i]) {\n"
	"				var id = room.tilemap[i][j];\n"
	"				var x = parseInt(j);\n"
	"				var y = parseInt(i);\n"
	"\n"
	"				if (id != \"0\" && tile[id] != null) {\n"
	"					drawTileInPixelBuffer(\n"
	"						renderer.GetDrawingSource(tile[id].drw),\n"
	"						tile[id].animation.frameIndex,\n"
	"						tile[id].col,\n"
	"						x,\n"
	"						y,\n"
	"						pixelBuffer);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//draw items\n"
	"		for (var i = 0; i < room.items.length; i++) {\n"
	"			var itm = room.items[i];\n"
	"			drawTileInPixelBuffer(\n"
	"				renderer.GetDrawingSource(item[itm.id].drw),\n"
	"				item[itm.id].animation.frameIndex,\n"
	"				item[itm.id].col,\n"
	"				itm.x,\n"
	"				itm.y,\n"
	"				pixelBuffer);\n"
	"		}\n"
	"\n"
	"		//draw sprites\n"
	"		for (id in sprite) {\n"
	"			var spr = sprite[id];\n"
	"			if (spr.room === room.id) {\n"
	"				drawTileInPixelBuffer(\n"
	"					renderer.GetDrawingSource(spr.drw),\n"
	"					spr.animation.frameIndex,\n"
	"					spr.col,\n"
	"					spr.x,\n"
	"					spr.y,\n"
	"					pixelBuffer);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return pixelBuffer;\n"
	"	}\n"
	"\n"
	"	function lerpColor(colorA, colorB, t) {\n"
	"		return [\n"
	"			colorA[0] + ((colorB[0] - colorA[0]) * t),\n"
	"			colorA[1] + ((colorB[1] - colorA[1]) * t),\n"
	"			colorA[2] + ((colorB[2] - colorA[2]) * t),\n"
	"		];\n"
	"	};\n"
	"}; // TransitionManager()\n"
	"\n"
	"// todo : is this wrapper still useful?\n"
	"var PostProcessImage = function(imageData) {\n"
	"	this.Width = 128;\n"
	"	this.Height = 128;\n"
	"\n"
	"	this.GetPixel = function(x, y) {\n"
	"		return imageData[(y * 128) + x];\n"
	"	};\n"
	"\n"
	"	this.GetData = function() {\n"
	"		return imageData;\n"
	"	};\n"
	"};\n"
	"\n"
	"var TransitionInfo = function(image, palette, playerX, playerY) {\n"
	"	this.Image = image;\n"
	"	this.Palette = palette;\n"
	"	this.PlayerTilePos = { x: playerX, y: playerY };\n"
	"	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };\n"
	"};\n";

#endif